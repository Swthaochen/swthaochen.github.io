<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js设计模式——观察者模式]]></title>
    <url>%2F2018%2F11%2F19%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[简介​ 观察者模式又称为发布—订阅模式，主要定义的是对象间一对多的关系。如果在关系中一个对象改变的时候，其他依赖的对象也能够及时得到这个对象的通知。这个用法实际上在JavaScript中也很常见，比如在Vue里面，多个组件监听一个变量的变化，当变量的值发生变化的时候，这些依赖的对象也能够很快得到这个值的变化从而重新渲染数据。 一个简单的实例我们先通过一个实例来说明这个观察者模式是怎样运行的： 12345678910111213141516171819202122232425262728var msgOffer = &#123;&#125;; //定义发布者var msgGetter = function(name)&#123; //定义接收者 this.name = name; this.listen = (type,msg) =&gt; &#123; console.log(this.name + '收到的消息是：' + msg) &#125;&#125;msgOffer.clientList = []; //定义收听者的回调函数msgOffer.addClient = function(func)&#123; this.clientList.push(func)&#125;msgOffer.sendMess = function()&#123; var num = this.clientList.length; for(let i = 0;i &lt; num;i++)&#123; func = this.clientList[i].listen; //这里调用apply函数可以给箭头函数传入当前环境this func.apply(this,arguments) &#125;&#125;var stu1 = new msgGetter('小明');var stu2 = new msgGetter('小红');msgOffer.addClient(stu1);msgOffer.addClient(stu2);msgOffer.sendMess('good','放假了');//执行的结果是//小明收到的消息是：放假了//小红收到的消息是：放假了 ​ 在上面这段代码里，首先我们定义了一个用来发送消息的对象msgOffer，也定义了一个接收消息的对象msgGetter。这里用name区分不同的收听者，并定义了他们的监听回调函数（回调函数使用箭头函数定义的，虽然箭头函数没有自己的this，但是在之后我们调用回调函数的时候使用apply可以给箭头函数定义一个环境this指向被调用的实例化对象）。之后向msgOffer添加了几个方法，一个是用来增加收听者的数组clientList，一个是用来发布消息的函数sendMess。发布消息的函数通过每次遍历收听者数组并调用他们的listen函数来调用回调函数。这样的话整个发布—订阅模式定义完毕。 能够选择性监听的观察者模式​ 上面的这段代码只是一个很简单的观察者模式，实际上他还是有很多设计上的问题。比如在上面，如果有的收听者只想接受特定的消息，比如在上述示例中，小明只想收听好消息，那么这个功能就需要加上去了。我们将代码改成下面这样： 12345678910111213141516171819202122232425262728293031323334var msgOffer = &#123;&#125;; //定义发布者var msgGetter = function(name)&#123; this.name = name;&#125;msgOffer.clientList = []; //定义收听者的回调函数msgOffer.addClient = function(obj,type,func)&#123; let client = &#123; obj:obj, type:type &#125; obj.listen = func; this.clientList.push(client)&#125;msgOffer.sendMess = function()&#123; var type = Array.prototype.shift.call(arguments) //取出消息的类型 var num = this.clientList.length; for(let i = 0;i &lt; num;i++)&#123; if(this.clientList[i].type == type)&#123; func = this.clientList[i].obj.listen var _that = this.clientList[i].obj; func.apply(_that,arguments) &#125; &#125;&#125;var stu1 = new msgGetter('小明');var stu2 = new msgGetter('小红');msgOffer.addClient(stu1,'good',function(msg)&#123; console.log(this.name + '收到的消息是：' + msg)&#125;);msgOffer.addClient(stu2,'bad',function(msg)&#123; console.log(this.name + '收到的消息是：' + msg)&#125;);msgOffer.sendMess('good','放假了');msgOffer.sendMess('bad','交作业') ​ 执行上面的这行代码，可以发现小明和小红收到了各自想要接受的消息类型。上面的这段代码在原来的基础上，在发布者里面clientList数组用来存放多个对象，这些对象都有一个obj属性和一个type属性，用来存放收听者对象和想要获得的消息的类型。在每次收听者订阅的时候，都会声明他想要收听的消息的类型，并且会传入一个事件处理函数。这样的话，在发布者每次发布消息的时候，都会发布这个消息的名称和内容，匹配到想要收听该类消息的收听者后，就会执行对应的回调函数。这样就实现了收听者对于消息的过滤。 使代码更通用​ 接下来我们做的事就是让这段代码更具有通用性。因为消息的发布者可能并不只是一个人，其他的对象也具有发布全体消息的功能，我们就对上面的代码进行一点修改使它更适用于更多的情况。 12 取消订阅​ 有订阅就有取消订阅，当一个对象已经不需要依赖另一个对象的时候就需要取消对其的监听。代码如下所示： 12345678910remove : function(key,name)&#123; let len = this.clientList.length; for(let i = 0;i &lt; len;i++)&#123; //找到了对应的函数 if(this.clientList[i].type == key &amp;&amp; this.clientList[i].obj.name == name)&#123; this.clientList.splice(i,1) break; &#125; &#125;&#125; 将事件全局化​ 上述的代码已经基本实现了我们的要求，但是接下来我们想让这个时间的发布成为一个全局的事件，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var eventer = (function()&#123; var clientList = [],addClient,sendMess,remove; addClient = function(obj,type,func)&#123; let client = &#123; obj:obj, type:type &#125; if(!obj.listen) &#123; obj.listen = func; this.clientList.push(client) &#125; &#125; sendMess = function()&#123; var type = Array.prototype.shift.call(arguments) //取出消息的类型 var num = this.clientList.length; for(let i = 0;i &lt; num;i++)&#123; if(this.clientList[i].type == type)&#123; func = this.clientList[i].obj.listen var _that = this.clientList[i].obj; func.apply(_that,arguments) &#125; &#125; &#125; remove = function(key,name)&#123; let len = this.clientList.length; for(let i = 0;i &lt; len;i++)&#123; //找到了对应的函数 if(this.clientList[i].type == key &amp;&amp; this.clientList[i].obj.name == name)&#123; this.clientList.splice(i,1) break; &#125; &#125; &#125;; return&#123; clientList:clientList, addClient:addClient, sendMess:sendMess, remove:remove &#125;&#125;)()var msgGetter = function(name)&#123; this.name = name;&#125;var stu1 = new msgGetter('小明');var stu2 = new msgGetter('小红');eventer.addClient(stu1,'good',function(msg)&#123; console.log(this.name + '收到的消息是：' + msg)&#125;)eventer.addClient(stu2,'bad',function(msg)&#123; console.log(this.name + '收到的消息是：' + msg)&#125;)eventer.sendMess('good','放假了') 离线通知​ 当然，还有一种情况就是。当发布者发布消息的时候，可能收听者并不在线不能及时收听到。我们需要做的就是当用户上线的时候，消息能够传达到收听者。这个时候我们需要一个存放离线事件的堆栈，当事件发布的时候，如果这个时候还没有订阅者来订阅这个事件，我们就将发布事件的动作放在一个函数里，这些函数将会被存放在堆栈中，下一次有对象来访问的时候，就将他执行。]]></content>
      <categories>
        <category>javascript设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[前端菜鸡的算法——排序算法总结]]></title>
    <url>%2F2018%2F11%2F17%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[快速排序算法简介​ 快速排序也是一种分治的思想，和归并排序是互补的。归并排序是先进行递归操作之后在进行归并排序，而快速排序算法是先进行排序后递归操作。归并排序的时候，一般切分的位置恰好在数组的中心位置，但是快速排序的切分的位置是取决于数据的内容。 简单的思路​ 快速排序的思路是随机的取a[lo]为划分元素，之后指定两个左指针i和右指针j分别指向a[lo]以及数组的最后一个元素的下一个元素。然后开始左指针扫描，遇到比a[lo]大的元素就停止，右指针开始从后往前扫描，遇到比a[lo]小的元素就停止。然后左右指针指向的那个两个数相互交换位置，左指针又开始扫描，重复以上的过程，直到两个指针相遇为止。这样的话，所有在左指针的元素都比a[lo]小，在a[lo]右边的元素都比他大。最后再交换a[j]和`a[lo]，本次的整个过程排序完毕。接下来就是要把a[i]两边的数进行递归排序，直到递归到只剩一个数。 ​ 这是第四版算法对于整个快速排序的过程图示，其中，j代表了在每一次递归排序的结束的时候和a[lo]交换位置的那个数的地址。并且在每次排序的时候，大小为1的子数组由于lo == hi所以不进行排序。 代码的实现接下来是对上述算法的代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243package QuickSort;public class Quick &#123; public static void sort(int[] a)&#123; sort(a,0,a.length-1); &#125; public static void sort(int[] a,int lo,int hi)&#123; if (hi &lt;= lo)&#123; return; &#125; int j = partition(a,lo,hi); &#125; public static int partition(int[] a,int lo,int hi)&#123; int i = lo,j = hi + 1; int v = a[lo]; while(true)&#123; while(a[++i] &lt; v) if (i &gt;= hi) break; while(a[--j] &gt; v)&#123; if (j &lt;= lo)&#123; break; &#125; &#125; if (i &gt;= j) break; exchange(a,i,j); &#125; exchange(a,lo,j); return j; &#125; public static void exchange(int[] a,int i,int j)&#123; int temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; public static void main(String[] args) &#123; int arr[] =&#123;5,2,9,4,3,1,6,8,5&#125;; Quick.sort(arr); for (int i = 0;i &lt; arr.length;i++) System.out.println(arr[i]); &#125;&#125; 算法分析​ 快速排序算法相较于希尔排序算法和归并排序算法而言，其优势在于进行的时候主要是在和一个数进行比较，在内循环中不需要太多的移动。其次就是快排得到比较次数相较于其他的两个算法而言少了很多。排序的效率取决于划分的位置，接下来我们将要来探讨这个算法的时间复杂度的影响。 ​ 理想的情况下，快排的时间复杂度最好是每次划分的时候划分点正好位于数组的中心，即正好能够将整个数组对半分。这个时候快排的比较次数正好满足分治递归的$$C_n=2C_N/_2+N$$。那么这个时候$$C_N~Nlg_n$$.但是，并不是所有的情况都能使划分点恰好落在中心位置，这种情况总是以一定的概率出现的，这就需要我们去计算这个算法的平均消耗代价。 ​ 结论：长度为N的无重复数组排序，快排平均需要$$~2NlnN$$次比较。这里是根据相关的数学推导得到的，具体的推导过程在算法第四版的186页，这里不做深入的探究 快排的改进算法快排最糟糕的情况，无非就是当数组划分的时候不均匀，尤其是如果一个数组顺序的时候，可能会出现一边的数组总是空的的情况，这个时候的时间复杂度： ​ $$N+(N-1)+(N-2)+….+2+1=(N+1)N/2$$ ​ 也就是说算法比较的次数约在$$N^2/2$$这个级别上。这是一种相当糟糕的情况，但是可以将待排的数组打乱，这样将会把比较次数降低很多。 切换插入排序​ 通过实验发现，在数据量很小的情况下，快速排序的性能不如插入排序，所以我们可以考虑在快速排序到小数组的时候利用插入排序来解决排序问题。这样可以明显提升。一般可以把代码中的 123if (hi &lt;= lo)&#123; return; &#125; 更改为： 1234if (hi &lt;= lo + M)&#123; insertSort(a,lo,hi)； return;&#125; 三取样划分​ 我们也可以通过三取样划分来提升性能。这时候实际上是将数组划分为了三部分，并设置了三个指针lt,i和gt。a[lo...lt-1]是小于当前比较的数，a[`lt…i-1]一部分是等于当前比较的数，a[i…gt]一部分是不确定的元素，a[gt+1…hi]大于当前比较的数。初始化的时候，首先将lt置为lo，将i置为lo+1，将gt置为hi，之后开始进行比较。如果： a[i]小于v，将a[lt]和a[i]交换，并将lt和i加一 a[i]大于v，将a[gt]和a[i]交换，将gt减一 a[i]等于v，将i加一 具体的代码见下面所示： 12345678910111213141516171819public static void threeQuick(int[] a,int lo,int hi)&#123; if (hi &lt;= lo) return ; int lt = lo,i = lo + 1,gt = hi; int v = a[lo]; while(i &lt;= gt)&#123; if (a[i] &gt; v)&#123; exchange(a,gt,i); gt--; &#125; else if(a[i] &lt; v)&#123; exchange(a,lt,i); i++; lt++; &#125; else &#123; i++; &#125; &#125; threeQuick(a,lo,lt - 1); threeQuick(a,gt + 1,hi); &#125;]]></content>
      <categories>
        <category>数据结构与算法分析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Webpack个人总结]]></title>
    <url>%2F2018%2F11%2F12%2FWebpack%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[​ 之前学习webpack由于版本问题以及学习的知识比较零散，所以走过很多弯路，现在通过自己一些编程的实践和看相关的书籍博客，来总结下相关的知识点。主要还是为了再熟悉一下webpack相关的打包流程，以及这种模块化的思维。也是对Vue，react这种框架的一种更加深入的理解。 ​ 首先新建一个webpack的空文件，然后按照流程先npm init，代表的是新建一个package.json文件，之后需要确认一些参数，当然如果想要全部输入默认值跳过提问环节的话可以直接输入npm init -y。之后会生成一个package.json文件。在这个文件里面，我们更关心script这一部分的内容，为了尝试这个功能我们做一个调试。在script里面增加这个字段： 1"my": "node index.js" ​ 其实，这里使用到了Npm Script，他是一个任务的执行者。允许在package.json这个文件里面使用script字段来定义任务。相当于我们使用npm run加上定义的字段可以来执行相关的指令。比如在这里输入npm run my就相当于输入了node index.js。 ​ 之后安装webpack。接下来我们来配置webpack。首先创建一个webpack.config.js。然后在在这个文件中添加下面的内容： 1234567891011const path = require('path') //path是webpack中的基本包，处理路径const config = &#123; //入口文件 entry: path.join(__dirname, 'src/js/test.js'), //__dirname表示当前文件所在的目录地址，利用join()拼接成绝对路径 // 输出文件 output: &#123; filename: 'bundle.js',//输出文件名 path: path.join(__dirname, 'dist') &#125;&#125;module.exports = config ​ 现在新建一个src文件，并在里面新建js文件，里面有个test.js文件，里面放入下面的代码： 12import '../../index'console.log('this is test') ​ 然后在下方的命令行中输入webpack。就可以进行打包了。最后输出了一个dist文件夹，里面有一个bundle.js文件就有我们之前的js文件里面的东西,。而且由于在这个文件中我们import了另外一个.js文件，这个js文件中的内容也被打包放在了上面。 ​ 现在我们在这里引入css文件。首先我们先在src文件下新建一个style文件，里面放入一个test.css文件： 123body&#123; color: red&#125; ​ 由于在webpack里面，一切的文件类型都可以用js来打包，所以这里我们在js文件中import引入这个css模块，在index.js文件中引入这个文件： 1import './src/style/test.css' 引入后由于在webpack并不能解析CSS，我们需要借助Loader机制去实现。在webpack.config.js中增加下面的内容： 12345678module:&#123; rules:[ &#123; test: /\.css$/, use:['style-loader','css-loader?minimize'] &#125; ] &#125; 这里声明了一个rules，test用正则表达式用来匹配需要用loader转换的CSS文件。这里，style-loader是将CSS代码写入到了js中去，css-loader正是读取css文件的，minimize用来压缩css文件。也可以写成下面的形式： 123456789use:[ 'style-loader', &#123; loader:'css-loader', options:&#123; minimize:true &#125; &#125;] ​ 当然，如果将css代码放在js文件里面执行会导致js文件变大并且加载网页的时间变长，所以我们可以利用相关的插件将CSS文件单独分离出来。在webpack3一般用的是extract-text-webpack-plugin，但是很遗憾，这个在webpack4里面已经被废弃了，取而代之的是mini-css-extract-plugin。 12345678910111213module:&#123; rules:[ &#123; test: /\.css$/, use:[MiniCssExtractPlugin.loader,'css-loader?minimize'] &#125; ] &#125;, plugins:[ new MiniCssExtractPlugin(&#123; filename: 'css/[name].[contenthash:7].css' &#125;) ] 之后开始配置dev-server,现在script里面输入下面的内容： 12"build": "cross-env NODE_ENV=production webpack --config webpack.config.js","dev": "cross-env NODE_ENV=development webpack-dev-server --config webpack.config.js" 其实上面两个是设置了两个指令，NODE_ENV定义了他们一个是生产模式一个是开发模式。–config后面是设置了webpack的配置文件。cross-env是说可以跨平台使用。同时这里需要安装几个插件： 1npm i html-webpack-plugin webpack-dev-server cross-env 然后修改webpack配置文件中的设置，先定义一个变量判断当前的运行环境： 1const isDev = process.env.NODE_ENV === 'development' 然后下面根据当前环境判断是否启动： 12345678910111213141516171819202122if (isDev) &#123; config.devtool = '#cheap-module-eval-source-map' //帮助在页面上调试代码, 优化显示 config.devServer = &#123; port: 8088, //host 可以通过localhost进行访问，同时也可以通过本机的内网id进行访问，就能够在别的网页或者手机上访问 host:'0.0.0.0', //overlay 编译过程有任何错误都直接显示到网页上 overlay: &#123; errors: true &#125;, // 当修改组件代码时，只重新渲染当前组件，不会让整个页面重新加载；hot启动后要添加以下两个插件 hot: true // 能够在运行后直接打开浏览器 // open: true &#125; // 启动webpack.hot功能的插件 config.plugins.push( new webpack.HotModuleReplacementPlugin(), //启动hot功能 new webpack.NoEmitOnErrorsPlugin() //减少不需要信息的提示 )&#125; 这时候运行npm run dev就能正常启动服务器了，但是这样显示出来的只是一个这样的页面： 说明我们还没有一个初始化的HTML文件。所以为了让webpack-server有一个默认的页面，我们再用一个插件来快速生成： 1234567var HtmlwebpackPlugin = require('html-webpack-plugin');//....plugins: [ new HtmlwebpackPlugin(&#123; title: 'Hello World app' &#125;)//在build目录下自动生成index.html，指定其title ], 这时候通过npm run build我们其实可以看见在dist里面生成了一个index.html文件，里面是这样的： 123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Hello World app&lt;/title&gt; &lt;link href="css/main.7a0631b.css" rel="stylesheet"&gt;&lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript" src="bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ​ 可以看见，这里里面包含了刚刚我们打包的css和js代码。这是因为不配置任何选项的html-webpack-plugin插件，他会默认将webpack中的entry配置所有入口thunk和extract-text-webpack-plugin抽取的css样式都插入到文件指定的位置。]]></content>
      <categories>
        <category>web基础知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ES6语法——Set和Map数据结构]]></title>
    <url>%2F2018%2F11%2F11%2Fset%E5%92%8Cmap%2F</url>
    <content type="text"><![CDATA[Set的用法​ 在python语言中，Set实际上是一个新的数据结构名叫集合。正如同数学当中的集合一样，在集合中的所有成员的值都是唯一的，不能有重复。ECMAScript6也仿造了这一点有一个Set数据结构。通常是通过new一个Set类型的对象，然后向里面添加元素。如果有重复他会自动去删除这些相同的元素。 123const s = new Set();[6,8,1,5,6,2,3,4,5].forEach(num =&gt;s.add(num));console.log(s); ​ Set函数可以接受一个数组，或者是具有Iterable接口的其他数据结构皆可。最为其参数。然后用来初始化这个数据结构。同时在Set中添加值的时候不会进行变量的强制转化，5和”5”不是同一个值。同时NaN在这里被认为和其自生是相等的。但是，两个对象总是被认为是不相等的，比如两个空对象之间是不等的。使用Array.from方法可以将Set数据结构转换为常见的数组类型，这样也就实现了数组去重的功能。 Set数据结构可以有四个遍历成员的方法可供选择，具体就是： keys()：返回键名遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：利用定义的回调函数进行对成员的遍历。 ​ 由于Set没有键值对，所以其实keys()和values()返回的内容完全相等。entries()返回的键值对两个成员也是相等的。 WeakSet的用法WeakSet和Set类似，也是不重复值的集合，但是它和Set有以下的区别： WeakSet的成员必须是一个对象，不能是其他类型的值。 WeakSet中的对象都是弱类型的，因此在垃圾回收的时候是不会考虑WeakSet的引用问题。这是因为在垃圾回收的时候，机制是依赖于引用一个计数，从而判断当前这个变量被多少对象引用。如果这个值为0，垃圾回收机制就不会释放这块内存。这时候会存在一个问题，就是在垃圾回收的时候忘记取消对回收变量的引用，从而内存不能被释放，进而导致内存泄露。而WeakSet就不会存在这样的问题。他适合临时存放一组对象，并且存放跟这个对象绑定有关的信息。如果这个对象已经没有其他的引用，就会直接从WeakSet中消失。因此，WeakSet中变量的数量是取决于垃圾回收机制的运行，由于垃圾回收机制是不可预测的，所以ES6中不允许对WeakSet进行遍历。 Map的用法：在传统的语法中，JS的对象是键值对的集合，但是一般只能是字符串当作键来使用。为了解决这个问题，ES6提供了一个名为Map的数据结构，这里键可以是各种类型的值，包括类。 同时Map中接受数组作为参数，并读取相关的信息，其实任何具有Iterator接口，且成员一双元素出现的数据结构都可以作为Map构造函数的参数。 12345678const items = [ ['name','liming'], ['sex','man']]const map = new Map(items);console.log(map.get('name'))const m2 = new Map(map)console.log(map.get('name')) ​ 需要注意的是，只有对同一个对象的引用，Map才会将他们视作为同一个键，否则即使他们的名称一样，但内存地址不同也不能视为是同一个键。下面的这个例子说明了这个问题： 12345678910const map = new Map()const k1 = ['aa']const k2 = ['aa']map.set(['bb'],123)console.log(map.get(['bb']))map.set(k1,123)console.log(map.get(k1))map.set(k2,456)console.log(map.get(k2)) 这样也就就觉了同名的问题，只要地址不一样，就视为不同的两个属性。 当然，如果map的键是一个普通的简单值二点时候，只要两个严格相等，依然是视为同一个键。]]></content>
      <categories>
        <category>js基础知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[标签]]></title>
    <url>%2F2018%2F11%2F06%2Fweb%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[web缓存机制在chrome的开发者工具中，在network /Size一列中可以看见一些请求，如果在这列中明确标明大小KB,B，说明这是一个网络请求，否则一般都会明确标明：from memory cache,from disk cache和from ServiceWorker. 优先级依次是： Service Worker Memory Cache Disk Cache 网络请求 1、Memory Cache ​ 它是内存中的缓存，和硬盘中的缓存相对。几乎所有的网络请求资源都会被浏览器加入到memory cache中去，但由于数量大所以是个短期的存储过程。当浏览的TAB页关闭的时候就失效了。或者一个页面占用的缓存过多的时候会导致前面的TAB缓存还没关闭就失效了。 ​ （1）preloader ​ 一般浏览器在打开网站的时候都是请求js/css，之后解析执行，然后再次解析下一个请求这样的穿行操作，那么现在，能不能一边解析js/css，一边请求下一个资源，这就是preloader所干的事。memory cache机制保证了一个页面中若有两个相同的请求的时候，（比如有两个相同href的)都实际上只进行一次请求。在匹配缓存的时候，除了会对他们的URL进行匹配。也会对他们的类型、CORS中的域名规则进行校对。比如在script中缓存的资源不能用在image图片类型的请求中，即使他们的src相同。 ​ （2）从memory cache中获取缓存内容的时候，浏览器自动忽略max-age=0,no-cache这些头部配置。因为memory cache只是短时间使用，大部分生命周期只有一次。max-size意思也就是“不要在下次浏览时使用”，和memory cache不冲突。如果真的不想让一个资源进入缓存，即使一次都不想，就可以使用no-store。这样memory cache就不会存储它了 2、disk cache ​ 也叫HTTP cache，是存储在硬盘上的缓存，是持久存储的，实际存在于文件系统当中。允许相同资源跨会话，甚至站点进行使用。他会严格根据HTTP头部信息进行判断哪些资源缓存，哪些可用，哪些过期了需要重新发送请求。命中之后浏览器会从硬盘中去读取资源，虽然过程会比内存中读取慢但是比网络请求快很多。一般大部分的缓存都是来自disk cache。 3.Service Worker ​ 以上的缓存机制和读取，缓存以及失效的行为都是通过浏览器判断进行的，只能通过设置响应的头部告诉浏览器应该做什么。而Service Worker就是一种更直接的方式，这个缓存是永久的，即使关闭TAB或者是关闭浏览器都不能将其删除。只有以下两种情况才会将其删除：手动调用API：cache.delete(resource)或者容量溢出。会被浏览器清除。如果Service Worker没有命中，就会调用fetch()方法继续获取资源。虽然这个时候没有命中Service Worker缓存，用了网络请求，但是在Chrome中依然会被标记为from Service Worker。 4.请求网络 如果前面的三个缓存都没有命中，那么就通过网络请求的方式获取。但是在获取完成之后，需要处理如何将这个资源放在缓存中去的问题： 根据Service Worker中的handle决定是否存入Cache Storage(额外的缓存位置)。 根据HTTP头部的相关字段决定是否存入disk cache memory cache 保存一份资源 的引用 开发与应用1.1简单的实例​ 在浏览器端对web的存储，一般都会在Windows上定义两个属性：localStorage和sessionStorage。他们都代表同一个持久化的关联数组，这个数组使用字符串来进行索引，并且在里面存储的所有的数都是以字符串的形式呈现。 ​ 接下来我们来通过实例来讲述对于web缓存中在编程上的简单运用。首先我们先来测试一下localStorage这个方法： 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script&gt; var number = 10; localStorage['number'] = number; console.log(localStorage['number']) console.log(typeof(localStorage['number']))&lt;/script&gt;&lt;/html&gt; ​ 这段代码最终的输出是10和string，首先我们定义了一个number，并且在localStorage中的number索引中存放了一个之位10的数。之后将这个值打印出来，可以看见，虽然在我们定义的时候这个number的类型是一个整形的数，但是在存储的时候localStorage将其存储为一个字符串型的数，这对sessionStorage来说也是一样的。并且对于localStorage而言，这个值只要我们不去手动调用相关的函数或是去进行相关的操作删除，他会一直保留在浏览器中。这也就是localStorage和sessionStorage两者的区别。 1.2存储的有效期和作用域上面说到，localStorage的作用域是永久的，永不过期。他的作用域是限定在文件源级别的。 文档源是通过协议、主机名以及端口三者来确定的。比如下面的例子中每个文档源都是不同的： http://www.baidu.com //协议：http 主机名：www.baidu.com https://www.baidu.com //不同的协议 http://wap.baidu.com //不同的主机名 http://ww.baidu.com:8080 //不同的端口 在同源文档中共享同样的localStorage数据。可以相互之间进行读写和覆盖对方的数据。但是非同源数据之间就不能够读取或者覆盖。 ​ 但是sessionStorage就不一样了。他的有效期是伴随着存储数据的脚本所在的最顶层窗口或是浏览器标签页一 致。如果窗口或者标签页被关闭，那么存储的数据也会被删除。（一些支持回复上次会话的浏览器可能存储的时间会更久点）。同样，sessionStorage的作用域也是限定在文档源中。但是不一样的是，sessionStorage是限定在窗口中的。即使是同源文档但是被渲染到了不同的浏览器标签页（不包括两个iframe元素）的时候，他们互相拥有的是各自的sessionStorage数据，且在这些标签页之间不能共享。互相之间不能进行读写或者覆盖。 1.3存储事件 ​ 对于web存储来说还有一个存储事件的监听函数addEventListener()方法，如果一个页面改变了一个值的时候，在另一个标签页中也会收到一个存储时间。对于session而言则是只有两个有牵连的窗口才会触发存储事件。在监听事件的回调函数的参数有几个属性，具体可以查阅相关文档。需要注意的是：localStorage和存储事件是采用的广播机制，浏览器会对访问相同站点的所有窗口发送消息。 cookie1.1相关的介绍​ cookie是Web浏览器存储的少量数据，也具体的页面或者站点相关。从底层上讲是一种http协议的一种扩展。cookie是可以在Web浏览器和服务器之间传输的，服务器脚本也可以读写客户端的cookie。 1.2cookie的相关属性：​ cookie具有名和值，还有一些可选的属性设置cookie的有效期和作用域。cookie的作用域只持续在Web浏览器的会话期间，关闭浏览器，cookie就会自动丢失。素以可以通过设置cookie的有效期来延长cookie的有效期。一旦设置，浏览器就会将cookie数据存储在文件中，等到超过了有效期就会删除。同样，cookie的作用域也是通过文档源和文档路径来确定。当然，也可以通过设置cookie的路径(path属性)让其他的页面也能够访问到。比如，对于http://www.baidu.com而言，如果路径是&quot;/cate&quot;，那么http://www.baidu.com/cate/index.html等都能够访问，如果直接将路劲设置成&quot;/&quot;，那么”http://www.baidu.com/index.html“也可以进行访问。并且，cookie也能实现不同域下的服务器之间读取同一个cookie，只需要设置cookie的domain属性就可以。同时，cookie还有一个属性叫做&quot;secure&quot;，表示的是cookie的值以何种形式通过网络传递。默认是通过不安全的形式（HTTP）传递。但如果标记成&quot;安全的&quot;，就只能通过HTTPS或者其他的安全协议连接传递。 1.3保存cookie​ 设置默认的cookie形式就是：name=value。因为cookie中的名或者值是不允许有分毫，逗号或者空白符出现，所以一般存储前需要用JavaScript全局函数encodeURIComponent()进行编码。读取的时候也需要采用decodeURIComponent进行解码。如果想要延长生命周期的话需要用max-age进行指定有效期，设置的单位是秒。之后在读取cookie的时候通过一个例子来说明cookie的存取。 1.4cookie的读取​ 利用JavaScript读取cookie的时候，返回值一般都是一个字符串，并且是由一串的名和值组成的，不同的对之间使用分号和空格分开，所以需要用split()将其分开。因为前面提到解码问题，所以这时候还需要通过decodeURIComponent进行解码，然后利用JSON.parse()转换成json对象。下面的这个例子说明了函数是如何进行存取cookie的： 1234567891011121314151617function setCookie(name,value,time)&#123; var cookie = name + "=" + encodeURIComponent(value); cookie += "; max-age=" + time; console.log(cookie) document.cookie = cookie console.log(document.cookie)&#125;function getCookie()&#123; var cookie = &#123;&#125;; var all = document.cookie; console.log(all) var list = all.split(" ; ") console.log(list)&#125;setCookie('liming',55,120)getCookie() ​ ​]]></content>
      <categories>
        <category>web基础知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[css性能]]></title>
    <url>%2F2018%2F11%2F04%2FCSS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"></content>
      <categories>
        <category>web性能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js迭代器模式]]></title>
    <url>%2F2018%2F11%2F04%2Ftitle%20js%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[JavaScript迭代器 在JavaScript的框架Jquery中，&amp;.each是一个常用的迭代函数，通过这个each函数可以实现对一个数组的迭代。]]></content>
      <categories>
        <category>javascript高级特性</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js代理]]></title>
    <url>%2F2018%2F11%2F04%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1.保护代理和虚拟代理在前面的js学习中，ES6语法里有个proxy对象可以创建一个代理，可以通过代理实现控制不同权限的对象对目标对象的访问，从而实现对一些对象访问的过滤。虚拟代理的意思是，把一些开销大的对象，放在真正需要她的时候去创建。这是为了系统性能和一些特殊需要的考虑。由于js不容易判断是哪个对象访问了目标，所以JavaScript中不容易实现保护模式。常用的还是虚拟代理。 2.利用虚拟代理实现图片的预加载在web开发时，如果给一个图片直接设置一个src属性，常常会因为网络状况的异常导致图片无法正常加载。所以一般刚打开的时候会发现里面都是空白。为了解决这个问题一般就是会用一张预加载的图片占位，异步加载图片。一直等到图片加载完成之后就将其渲染到组件中去。]]></content>
      <categories>
        <category>javascript高级特性</category>
      </categories>
      <tags>
        <tag>JavaScript设计模式</tag>
        <tag>虚拟代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[懒加载与预加载]]></title>
    <url>%2F2018%2F11%2F04%2F%E6%87%92%E5%8A%A0%E8%BD%BD%E4%B8%8E%E9%A2%84%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[懒加载和预加载都是前端性能优化中对于图片的优化。从而使得用户有更好的上网体验 一、懒加载 1.1HTML中的懒加载方式 懒加载就是在延迟加载。一般的做法是不设置或者设置一个相同的图片src用来占位。并且将真正需要加载的图片地址放在img标签自定义的属性中（如：data-origin）。正如很多电商平台的做法，等到用户将浏览器的时候滑至该图片的位置上时，这时候由js监听并且将自定义属性中的值存放在src中。这时候图片才开始加载。由此达到懒加载的效果。这样做的目的也是为了防止页面一次请求浏览器的数据量服务的数据量过大导致后面的一些js因为图片的渲染迟迟不能被执行导致出现一些错误，同时也能够防止服务器响应慢，卡顿的问题。而且一般情况下用户访问页面的长度不会太大，如果都一次性请求所有的资源的话会造成很大的带宽浪费。所以才会采用懒加载的方式进行。这样可以避免很多无效的请求和加载。 懒加载的具体步骤是： 在图片的img标签里src置为空或者直接防止一个默认的地址，真正的地址放在自己定义的标签属性名里。 页面加载完成后，根据用户的滑屏情况进行判断图片的位置是否在用户当前的视野内。如果在，就将data-origin置为真实的值。 当用户滑动视野的时候判断图片是否进入视野，如果进入就将data-origin的值放在src中，并且将之前自定义的属性删除。 接下来通过一个实例来说明懒加载判断图片是否进入可视范围从而加载图片。 12345678910111213141516171819202122232425262728293031323334353637&lt;body&gt; &lt;div id="root"&gt;啊啊啊啊啊啊A啊啊啊啊啊&lt;/div&gt; &lt;!-- 若干行标签 --&gt; &lt;div id="root"&gt;啊啊啊啊啊啊A啊啊啊啊啊&lt;/div&gt; &lt;img src="" class="image-item" lazyload="true" data-original="http://pic26.nipic.com/20121213/6168183_004444903000_2.jpg" /&gt;&lt;/body&gt;&lt;script&gt;var viewHeight = document.documentElement.clientHeight // 可视区域的高度function lazyload () &#123; // 获取所有要进行懒加载的图片 var eles = document.querySelectorAll('img[data-original][lazyload]') Array.prototype.forEach.call(eles, function (item, index) &#123; console.log(item) var rect if (item.dataset.original === '') return rect = item.getBoundingClientRect() // 图片一进入可视区，动态加载 if (rect.bottom &gt;= 0 &amp;&amp; rect.top - 40&lt; viewHeight) &#123; !function () &#123; var img = new Image() img.src = item.dataset.original img.onload = function () &#123; item.src = img.src &#125; item.removeAttribute('data-original') item.removeAttribute('lazyload') &#125;() &#125; &#125;)&#125;// 首屏要人为的调用，否则刚进入页面不显示图片lazyload()document.addEventListener('scroll', lazyload) 首先这里定义了很多个div标签，是得在最下方的图片由于不在视野范围内所以暂时不进行加载。等到当用户滑动屏幕到图片的上边位置距离视野上方位置50像素的时候，图片的src被设置，同时进行没图片的加载。这里就实现了这个图片的懒加载。这楼里需要注意的是，在监听用户滑动的时候，我们用到了getBoundingClientRect这个函数，起作用是获取某个元素相对于视窗的位置。获得的都是某个元素的上下左右距离上边试图或者左边视图的距离。 1.2Vue上实现的懒加载 在Vue中，懒加载一般会使用插件vue-lazyload来实现，首先需要安装这个插件 1npm install vue-lazyload 在入口文件main.js中直接引用并使用。 1import VueLazyLoad from 'vue-lazy 之后在这里直接使用这个模块： 1Vue.use(VueLazyLoad) 当然也可以根据官方文档中提供的API自定义选项： 1234Vue.use(VueLazyLoad,&#123; error:'dist/error.png', loading:'dist/loading.png'&#125;) 同时在标签上修改图片的显示方式为懒加载的方式,注意这里是直接将src改成v-lazy： 1&lt;img v-lazy="/static/img/"+item.productImage/&gt;]]></content>
      <categories>
        <category>Web性能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js代理]]></title>
    <url>%2F2018%2F11%2F04%2Fjs%E2%80%94%E2%80%94%E9%97%AD%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[js——闭包问题一、理解闭包首先根据下面的例子来理解闭包的概念： 1234567891011121314151617var ourVar = 'liming'var later;function outerTest()&#123; var inner = 'haha'; function innerTest()&#123; console.log(inner); console.log(ourVar) &#125; later = innerTest;&#125;outerTest();later();//运行的结果是：//haha//liming 在上面的代码中，在外部函数我们声名了一个变量inner，然后又声名了一个内部函数innerTest，接下来在内部函数中访问全局变量ourVar和函数内的变量inne，之后为了在全局中能够调用这个内部函数，在全局变量中设置了一个变量接受这个函数，通过调用outerTest创建内部函数并将内部函数赋给later，之后调用later。可以看见，即使现在内部作用域消失在执行内部函数时，内部变量依然存在。 这是因为在外部函数声明内部函数的时候，不仅定义了函数的声明，而且创建了一个闭包。闭包不仅包含了函数的声明，还包括了在函数声明时该作用域的全部变量。在执行内部函数的时候，虽然作用域已经消失，但是通过闭包，还能访问原始的作用域。 二、使用闭包1.封装私有变量虽然JavaScript不支持私有变量，但我们可以利用闭包的特性来实现私有变量的基本功能。 12345678910111213141516171819function student()&#123; var age = 23; this.name = "liHua" this.getAge = function()&#123; return age; &#125; this.increase = function()&#123; age++; &#125;&#125;var stu1 = new student();console.log(stu1.age)console.log(stu1.name)console.log(stu1.getAge())//运行结果//undefined//liHua//23 上述代码中，我们定义了一个age作为student类中的私有属性。由于js的作用域规则的限制，只能在构造器内部访问该变量。所以直接访问stu1.age执行的结果就是undefined。为了让外界可以接触这个变量，可以利用getAge来向外暴露。虽然这时候，函数的作用域结束了，但实例化对象通过this拥有这个作用域，所以可以访问他的方法。注意这里直接var定义的属性和利用this定义的属性是不一样的。]]></content>
      <categories>
        <category>javascript高级特性</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js代理]]></title>
    <url>%2F2018%2F11%2F04%2Fjs%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[1.使用代理控制访问 2.使用代理的优化代码 2.1简单的说明 2.2node中运行代码的不同探究 2.3原因解释 1、使用代理控制访问 ​ 代理是ES6语法提出的，是我们通过代理控制对另一个对象的访问。可以将代理理解为通用化的setter和getter方法，区别就是每个setter和getter只能控制单个对象的属性，而代理可用于对象交互的通用处理，包括调用对象的方法。首先先看下面的这个例子。 1234567891011121314151617181920212223242526272829303132const people = &#123; name:'liming'&#125;const father = new Proxy(people,&#123; get:(target,key) =&gt; &#123; console.log(target[key]) if(key in target) return target[key] else&#123; console.log('The value do not exits'); return undefined; &#125; &#125;, set:(target,key,value) =&gt; &#123; console.log('Something changed'); target[key] = value; &#125;&#125;)console.log(father.name)father['name'] = "mingming"console.log(people.name)console.log(father.ta)// 执行结果// liming// liming// Something changed// mingming// undefined// The value do not exits// undefined 这里我们定义了一个people对象，并设置了他的代理father，并且在father中指定了getter和setter方法。首先先查看father的名称，这时候会触发father的getter并返回名称。如果这里在getter中不返回，在console.log返回将会是undefined。之后对father进行了赋值，调用了father的setter方法，并将target即people的name属性进行了重新设定。之后又对原来people中不存在的一个变量ta进行访问，这时候还会去调用getter方法，然后检查key不在target对象中的时候就会返回一个undefined。 2、使用代理的优化代码 简单的说明 使用代理同时还可以优化代码。在不使用代理的时候，对一个对象的设置需要进行很多次的defineProperty的设置，如果需要为一个对象添加很多属性的时候就显得很多。但是利用了代理就能够很方便的解决这些问题。 123456789101112131415161718192021222324252627282930313233343536function makeConstructor(target)&#123; return new Proxy(target,&#123; get:(target,property) =&gt;&#123; console.log('Get function invoked') return target[property]; &#125;, set:(target,property,value) =&gt; &#123; console.log('Set function invoked'); target[property] = value; &#125; &#125;)&#125;let peo = &#123;name:'Yoshi'&#125;peo = makeConstructor(peo);console.log('分割线1')console.log(peo.name)console.log('分割线2')peo.weapon = 'shui'console.log('分割线3')console.log(peo.weapon)console.log('分割线4')console.log(peo)// 运行结果：// 分割线1// Get function invoked// Yoshi// 分割线2// Set function invoked// 分割线3// Get function invoked// shui// 分割线4// Get function invoked// Get function invoked// Get function invoked 首先定义了一个构造器，使用了一个对象target作为被代理的对象。然后调用了makeConstructor来构造对象和代理之间的关系，并在makeConstructor返回了新建的代理，并设置了相关的一些方法。然后可以发现，最开始对象只有一个name属性，在访问的时候会触发getter方法并返回它的值。之后对peo对象中之前不存在的一个属性weapon进行了设置，这时候可以看见触发了setter方法，并在对象中添加了一个名为”weapon”属性。之后又查看了刚刚添加的weapon方法。在最后可以看见，我们console.log输出peo这个对象，结果发现调用了三次get方法。为了探究我们对get方法进行一些处理。 node中运行代码的不同探究 12345678910111213141516171819202122232425262728function makeConstructor(target)&#123; return new Proxy(target,&#123; get:(target,property) =&gt;&#123; //console.log(property) console.log('Get function invoked') return target[property]; &#125;, set:(target,property,value) =&gt; &#123; target[property] = value; &#125; &#125;)&#125;let peo = &#123;name:'Yoshi'&#125;peo = makeConstructor(peo);peo.weapon = 'shui'peo.weapon1 = 'shui'peo.weapon2 = 'shui'console.log(peo)// //运行的结果：// Get function invoked// Get function invoked// Get function invoked// &#123; name: 'Yoshi',// weapon: 'shui',// weapon1: 'shui',// weapon2: 'shui' &#125; 刚开始我的理解是在输出peo的时候，首先对peo这个类整体的访问会触发一次getter，之后对他里面的两个属性name和weapon访问取值的又是两次调用getter，这样就恰好三次。但是当我再增加几个属性的时候结果还是三次。然后就在get中每次输出property，可以看到下面的几个输出： 123Symbol(util.inspect.custom)inspectSymbol(Symbol.iterator) 原因解释 ​ 因为我是在node里面运行这个代码的，所以console.log出来的实际上是将这个对象进行了处理输出了对象中的属性。实际上在chrome浏览器的控制台中输入的话运行出来的结果应该是一个代理的对象。然后由于在node中对对象进行了一些处理，所以难免会对get进行调用从而将对象转化成可视的字符串类型。以上这些代码实际上都是对这个对象进行的一系列的操作。是node中util自带的一些模块，就是为了弥补JavaScript中原始方法的不足。 3.使用代理实现自动的填充属性 当我们拥有一个对象具有很长一串属性的时候，通常我们可以通过代理来生成它没有的属性，避免带妈妈的重复和繁重。 12345678910111213141516function Folder()&#123; return new Proxy(&#123;&#125;,&#123; get:(target,property)=&gt;&#123; if(!(property in target))&#123; target[property] = new Folder(); &#125; return target[property]; &#125; &#125;)&#125;const myFile = new Folder();try&#123; myFile.root.first.second.next = "aa.txt";&#125;catch(e)&#123; console.log('error')&#125; 在try中虽然myFile并没有后面的一系列属性，但当我们读取的时候会调用代理中的get方法帮我们创建，这样的话即使这个属性不存在也不会出现undefined的问题。 4.使用代理实现数组的负索引 ​ 在python等语言中，是允许使用负索引来查找对象的，但是JavaScript不允许这样做，但是通过代理的方法我们可以来模拟这个过程。 123456789101112131415161718192021function createArray(array)&#123; return new Proxy(array,&#123; get:(target,index) =&gt;&#123; index = +index return array[index &lt; 0 ? target.length + index : index]; &#125;, set:(target,index,value) =&gt; &#123; index = +index return array[index &lt; 0 ? target.length + index : index] = value &#125;&#125;)&#125;const test = ['hh','sss','llll','iii']const test2 = createArray(test)console.log(test2[-1]);console.log(test2[-3]);console.log(test[-1])//执行的结果是// iii// sss// undefined 这里通过一元运算符+将属性名变成了数值。然后在代理中对他们的负数情况进行了相应的处理。然后新建一个test的数组，并创建它的代理，通过代理可以用负索引来访问数组中的值。 5.代理的性能消耗 相比较正常访问对象而言，使用代理去访问性能会慢很多，比如上个例子中，使用代理访问数组相互比较正常访问数组而言。在Chrome上时间为正常的50倍，所以使用代理的时候还是需要谨慎。如果是在多性能不敏感的情况下使用。]]></content>
      <categories>
        <category>javascript高级特性</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js实现继承]]></title>
    <url>%2F2018%2F11%2F04%2Fjs%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[js实现继承一、尝试实现原型继承 123456789101112function Person()&#123;&#125;Person.prototype.dance = function()&#123;&#125;;function Ninja()&#123;&#125;Ninja.prototype = new Person();const ninja = new Ninja();console.log(ninja instanceof Ninja); //trueconsole.log(ninja instanceof Person) //trueconsole.log(ninja instanceof Object) //true 当定义一个Person函数的时候，同时也创建了一个Person原型，该原型通过其construtor属性引用函数的本身。同时下面也扩展了Person原型，加入了相关的方法。后面我们也定义了一个Ninja函数，并且该函数原型也有一个constructor属性引用函数本身。为了实现继承，将Ninja的原型赋为Person的实例。之后每创建一个Ninja对象的时候，新创建的Ninja对象将设置为Ninja的原型属性所指向的对象，即Person。 当访问Ninja对象的dance方法时，js首先会查找Ninja对象本身。没有就会找他的原型即Person。Person不具有dance方法就会再接着查找Person对象的原型，这时候找到了dance方法。执行instance操作符的时候，可以判定函数是否继承原型链上的对象功能。 其实实现继承还可以直接使用Person的原型对象作为Ninja的原型，如Ninja.prototype = Person.prototype。这样做会导致Person原型上发生的所有变化都被同步到Ninja原型上（Person原型和Ninja原型是同一个对象），会有一定的副作用。 constructor属性的问题​ 仔细观察可以发现，上述代码中，会存在丢失Ninja与Ninja初始原型的之间的关联，这是一个问题。如果利用constructor检查一个对象是否由某一个函数创建的时候，去检查Ninja会得到的是Person。显然这个答案是错误的。 配置对象的属性在js中，对象是通过属性描述的，可以通过配置一下关键字： configurable——如果设置为true，则可以修改或删除属性。 enumerate——如果如果设置为true，则可在for-in循环对象属性出现 value——指定其属性的值 writable——如果为true，可以通过赋值语句修改属性值 get——定义getter函数，当访问属性时发生调用，不能与value和writable同时使用。 set——定义setter函数，当对属性赋值的时候调用，不能与value和writable同时使用。 当然，可以使用内置的Object.defineProperty方法属性定义一个属性： 123456789101112131415var ninja = &#123;&#125;;ninja.name = "haha";ninja.sex = 'man';Object.defineProperty(ninja,'test',&#123; configurable:false, writable:true, value:false, enumerable:false&#125;);console.log('test' in ninja) //truefor(let m in ninja)&#123; console.log(m) //name,sex&#125; 利用上面的方法，就可以解决constructor被覆盖的问题，即通过Object.defineProperty在Ninja.defineProperty上定义一个constructor属性。 instanceof操作符在上面的例子中，虽然Ninja的原型是Person，但是通过instanceof还是可以发现ninja instanceof Ninja的返回值是true，说明ninja也是Ninja的实例。在这个过程中，javascript首先检查Ninja函数的原型——new Person()对象，检查他是否存在ninja的原型链上。由于new Person()对象确实是ninja的原型，所以表达式为true。实际上，ninja实例的原型链是由new Person（）对象和Person的原型组成的。 ES6语法中使用class关键字：1234567891011class test&#123; constructor(name)&#123; this.name = name; &#125; swing()&#123; return true; &#125;&#125;var haha = new test('tom');console.log(haha.swing()) 从上面的代码可以看出，ES6语法支持使用类似其他面向对象语言的方式用class来定义一个类。但实际上，class只是个语法糖，底层仍是基于原型的实现。上述定义类可转换成下面的ES5代码： 123456function Ninja(name)&#123; this.name = name;&#125;Ninja.prototype.swing = function()&#123; return true;&#125; 同时在ES6中还支持定义像Java一样的静态方法。 123456789101112131415class test&#123; constructor(name)&#123; this.name = name; &#125; swing()&#123; return true; &#125; static sum(x,y)&#123; return x + y; &#125;&#125;console.log(test.sum(1,2))var haha = new test('tom');console.log(haha.swing()) 实现继承js也可以像java一样利用extends来实现继承： 12 在student构造器中通过关键字super调用基类Person的构造函数。]]></content>
      <categories>
        <category>javascript高级特性</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js代理]]></title>
    <url>%2F2018%2F11%2F04%2Fjs%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[js模式——基本技巧反模式：暗示全局变量12 这里并没有对result进行定义，但是依然可以对result进行赋值和访问。只是因为在这里使用了反模式，暗示全局变量。这里没有用var定义的话result就是一个全局变量。 带有var声明的原型链：var a = b = 0;在这个语句中，a是局部变量，b是全局变量。 变量释放时的副作用隐含全局变量和明确定义的全局变量有一定差别，体现在能否使用delete操作符删除变量： 使用var创建的全局变量（这类变量在函数外部创建）不能删除 不使用var创建的隐含全局变量（尽管他是在函数内部创建的）可以删除 可以看出实际上隐含全局变量实际上并不是真正的变量，而是全局对象的属性。属性是可以用delete删除的，而变量不行。 12 一般提倡在函数中先声明变量，在进行相关的操作，不然可能会出现一下的问题： 123456function test()&#123; console.log(name) //undefined var name = "xiaojun" console.log(name) //xiaojun&#125;test() 虽然这里，变量name在第一行感觉是一个隐含全局变量，但是由于在后面又声明了一个name，所以这里变量是一个局部变量，而由于上面的变量还没有用var定义，所以输出是未定义。]]></content>
      <categories>
        <category>javascript高级特性</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js原型]]></title>
    <url>%2F2018%2F11%2F04%2F%E5%8E%9F%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[一、理解原型12345678910111213141516171819let obj1 = &#123; test1:'test1'&#125;;let obj2 = &#123; test2 : 'test2'&#125;;let obj3 = &#123; test3 : 'test3'&#125;;console.log(obj1.test2)Object.setPrototypeOf(obj1,obj2);console.log(obj1.test2)Object.setPrototypeOf(obj2,obj3);console.log(obj1.test3)//运行结果：// undefined// test2// test3 上面的这行代码中，首先定义了三个类：obj1,obj2和obj3.由于obj1不具有test2的属性，所以这里obj1.test2输出的结果为undefined。之后又通过Object.setPrototypeOf(obj1,obj2);方法，将obj2设置为obj1的原型。所以这时候，再次访问的时候，obj1中没有的属性将去它的原型中找。若再将obj3设置为obj2的原型，那么这时候就形成了原型链。obj1没有的属性去obj2中找，找不到就去obj3中找。直到没有更多的原型可以查找的时候，就会停止查找。 二、实例属性与原型属性现在看下面的一个例子： 1234567891011121314function Obj()&#123; this.test = true; this.callStr = function()&#123; return !this.test; &#125;&#125;Obj.prototype.callStr = function()&#123; return this.test;&#125;const obj = new Obj();console.log(obj.callStr())//最终返回的结果是false 通过以上这段代码可以知道，返回的结果是false。在这里我们定义了一个与实例方法同名的原型方法，然后通过结果可以看出，实例会隐藏原型中与实例同名的方法，在构造函数的内部，关键字this指向的是新创建的对象，所以在构造器中添加的属性直接就在实例上。当我们利用obj访问的时候，就不需要遍历原型链，直接找到返回构造器中的创建的属性即可。 12 通过以上代码发现，首先定义了一个构造函数，并且实例化了一个类之后，这个对象指向了类的原型。再在原型上添加了一个myFunc的方法，此时对于对象obj1而言，这个方法同样也在里面。但是，之后我们替换了构造器的原型，仅仅有一个myFunc2的方法，这时候obj1已经被实例化了，但是之前的原型依然存在于obj1的实例中，所以通过原生链依然可以访问到myFunc这个方法。同时也能访问新的方法。这里，obj1的原型中（旧的），constructor属性指向了构造函数，而由于赋予了新的原型，这个时候构造函数又指向了新的原型。对象与函数原型之间的关系是在对象创建的时候建立的，新创建的对象将保持新的原型，旧的对象保持原来的原型。 12 这里，我们利用构造器创建了一个实例对象。使用这个对象的constructor属性创建第二个实例。很明显，新创建的对象ninja是Nanji的实例。但同时，ninja和ninja2不是同一个对象。这也说明，我们不需要利用原始的构造函数就可以直接创建对象，即使原始构造函数已经不在作用域内，这时候完全可以用构造函数的应用。]]></content>
      <categories>
        <category>javascript高级特性</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[生成器和Promise]]></title>
    <url>%2F2018%2F11%2F04%2Fjs%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8Cpromise%2F</url>
    <content type="text"><![CDATA[一、生成器函数类似于python，js也有自己的生成器，其基本的使用和定义方式如下所示： 123456789function* myGenertor()&#123; yield 'test1'; yield 'test2'; yield 'test3';&#125;for(let aa of myGenertor())&#123; console.log(aa)&#125; 最后，这个程序依次输出的是test1.test2和test3，这也是JavaScript的一个生成器。在定义函数的时候在function后面加一个*表示这是一个生成器函数，并通过关键字yield返回相应的值。并且，对于生成器函数来说，它不会像普通函数一样停止执行，而是当一个值的请求到来后，生成器就会从上次离开的地方继续开始执行。示例如下： 1234567891011function* myGenertor()&#123; var bb = 1; yield bb; bb++; yield bb; yield bb; &#125; for(let aa of myGenertor())&#123; console.log(aa) &#125; 从上面这个例子可知，第一次调用myGenenrtor这个生成器函数的时候，首先定义了一个名为bb的变量并且初始化为1，然后将这个值返回。第二次调用的时候，生成器不会像普通函数那样，再次从函数的开始执行，而是从上次执行的语句之后又开始执行b++，并返回此时bb的值为2.然后继续这个过程，返回的值是3.在这里，for-of循环就是对迭代器进行迭代的语法糖。 二、通过迭代对象控制生成器首先看下面这个例子 123456789101112131415161718function* myGenertor()&#123; var bb = 1; yield bb; bb++; yield bb; &#125; var myIterator = myGenertor();console.log(myIterator);console.log(myIterator.next())console.log(myIterator.next())console.log(myIterator.next())//执行的结果为//&#123;&#125;//&#123; value: 1, done: false &#125;//&#123; value: 2, done: false &#125;//&#123; value: undefined, done: true &#125; 在上面这个例子中，依然定义了一个生成器函数myGenertor，接下来调用这个生成器函数，但这一次赋给了一个名为myIterator的一个变量，如果直接输出这个变量，得到的是一个空的对象，只有对这个对象执行接口方法next(),生成器才开始执行代码，当代码执行到yield关键字的时候，生成一个中间结果并且返回一个新的对象，其中封装了一个结果值和指示完成的指示器。每当生成器生成一个值之后，生成器就会非阻塞挂起，等待下一次请求的到达。当没有可执行的代码的时候，生成器就会返回一个value为“undefined”，done为true的值，表示他的状态已完成。 三、利用生成器函数把执行权交给下一个生成器123456789101112131415function* myGenerator(action)&#123; const imposter = yield("hello" + action); //第二次next开始执行 console.log(imposter) yield("nihao (" + imposter + ")" + action);&#125;const test = myGenerator("test1");console.log(test.next())console.log(test.next("myotherTest"))//执行结果：// &#123; value: 'hellotest1', done: false &#125;// myotherTest// &#123; value: 'nihao (myotherTest)test1', done: false &#125; ​ 上面这个实例中，在迭代器上使用yield*操作符，程序会跳转到另一个生成器上执行，这一切对于最初调用的迭代器而言都是透明的。 四、迭代器与生成器之间的交互现在来讨论以下迭代器与生成器的交互问题，从而更好的理解生成器与迭代器之间的关系。首先先来看下面这段代码： 123456789101112131415function* myGenerator(action)&#123; const imposter = yield("hello" + action); //第二次next开始执行 console.log(imposter) yield("nihao (" + imposter + ")" + action);&#125;const test = myGenerator("test1");console.log(test.next())console.log(test.next("myotherTest"))//执行结果：// &#123; value: 'hellotest1', done: false &#125;// myotherTest// &#123; value: 'nihao (myotherTest)test1', done: false &#125; ​ 这里，我们给生成器一个参数action。首先新建一个迭代器并赋给test这样的一个变量。并且这个时候，我们已经给myGenerator赋予了一个参数，所以在下一次调用的时候，会输出”hello”加上这个参数。之后，生成器就在yield这里被挂起，imposter始终都没有被赋值直到下一次再次调用next()的时候，此时imposter被赋予了next中的值，这里是因为yield的返回值就是下一次调用next()的参数，所以imposter就被赋值。这也是为什么不能通过第一次调用next()向生成器提供参数的原因，但还是可以在构造的时候提供初值。（构造的时候仅仅是给参数赋值，但生成器函数是不会运行的） 五、生成器异常和处理123456789101112131415function* myGenerator(data)&#123; try&#123; yield "hello"; &#125;catch(e)&#123; console.log("出错了！！" + e) &#125;&#125;const test1 = myGenerator();console.log(test1.next());test1.throw("迭代器抛出了一个错误");// 运行结果：// &#123; value: 'hello', done: false &#125;// 出错了！！迭代器抛出了一个错误 ​ 这里将生成器中全部的代码装入try-catch块中去。在创建了迭代器之后，通过调用迭代器中的throw方法抛出异常，并利用生成器函数中的catch语句进行异常的接受和处理。 六、promise和生成器解决异步问题首先测试下面的这段代码： 12345678910111213141516171819function delay(time)&#123; var promise = new Promise(function(resolve,reject)&#123; setTimeout(resolve,time) &#125;) return promise;&#125;function* test()&#123; yield delay(300).then(() =&gt; console.log(1)); yield console.log(2) yield delay(300).then(() =&gt; console.log(3)); yield console.log(4)&#125;const a = test()a.next();a.next();a.next();a.next();//输出为2，4，1，3 由于在生成器中存在异步操作，所以在使用next操作的时候，会存在异步问题。这时候检查第一个a.next()的返回值的时候，可以看到返回以下的结果： 12&#123; value: Promise &#123; &lt;pending&gt; &#125;, done: false &#125;1 说明，对于一个promise，它的then()函数的返回值同样是一个promise对象。利用这个特性，将下次想要顺序执行的同步操作中的值放在promise函数的then之后，就可以得到我们想要的结果。 1234567const a = test()a.next().value.then(() =&gt; &#123; a.next() a.next().value.then(() =&gt; &#123; a.next() &#125;)&#125;) 可以发现，如果在遇到异步请求的时候，就使用.then()，如果遇到同步操作，就直接next()即可，所以可将上述代码整理成为下面的方法，利用递归来实现这个过程： 12345678910111213function himmel(gen) &#123; const item = gen.next() if (item.done) &#123; return ; &#125; const &#123; value, done &#125; = item if (value instanceof Promise) &#123; value.then((e) =&gt; himmel(gen)) &#125; else &#123; himmel(gen) &#125;&#125; 最终，执行的结果就是按照顺序执行的1，2，3，4​ ###番外 异步问题的另一种解决方案——利用闭包来实现： 首先还是先看下面这个异步的例子： 123456789101112131415161718192021222324252627282930313233function delay(time)&#123; var promise = new Promise(function(resolve,reject)&#123; setTimeout(resolve,time) &#125;) return promise;&#125;function test()&#123; for(var i = 0;i &lt; 5;i++)&#123; delay(300).then(function()&#123; console.log('这是第' + i + '一段输出'); &#125;) console.log('这个应该在第' + i + '次异步操作执行结束后才输出') if(i == 4)&#123; console.log('end') &#125; &#125;&#125;test()//运行结果//这个应该在第0次异步操作执行结束后才输出//这个应该在第1次异步操作执行结束后才输出//这个应该在第2次异步操作执行结束后才输出//这个应该在第3次异步操作执行结束后才输出//这个应该在第4次异步操作执行结束后才输出//end//这是第5一段输出//这是第5一段输出//这是第5一段输出//这是第5一段输出//这是第5一段输出 ​ 上面的代码是一个典型的异步的问题，由于delay()是一个异步操作，所以在程序运行到delay的时候，将这个操作放在异步事件的队列中，先去进行同步操作，于是本该在异步操作执行结束之后执行的语句被优先执行了。并且程序在异步操作还没来得及开始就宣布结束了。并且之后，由于全局变量中的i已经增加到了5，所以最后得到的都是5，这显然不是我们预期的结果。首先解决i的问题，这里需要加一个闭包，将每次执行的i纪录下来，并且利用递归，在每次异步操作回调之后在递归下一次的操作，直到达到程序的终点为止。这样也就完成了程序从异步变为同步的操作。具体代码如下所示： 12345678910111213141516171819202122232425262728293031323334function delay(time)&#123; var promise = new Promise(function(resolve,reject)&#123; setTimeout(resolve,time) &#125;) return promise;&#125;function test()&#123; (function iter(i)&#123; delay(300).then(function()&#123; console.log('这是第' + i + '一段输出'); console.log('这个应该在第' + i + '次异步操作执行结束后才输出') if(i == 4)&#123; console.log('end') &#125;else&#123; iter(i+1) &#125; &#125;) &#125;)(0)&#125;test()//运行结果：//这是第0一段输出//这个应该在第0次异步操作执行结束后才输出//这是第1一段输出//这个应该在第1次异步操作执行结束后才输出//这是第2一段输出//这个应该在第2次异步操作执行结束后才输出//这是第3一段输出//这个应该在第3次异步操作执行结束后才输出//这是第4一段输出//这个应该在第4次异步操作执行结束后才输出//end]]></content>
      <categories>
        <category>javascript高级特性</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[apply和call的用法]]></title>
    <url>%2F2018%2F11%2F03%2Fcall%E5%92%8Capply%2F</url>
    <content type="text"><![CDATA[call和apply这两个方法在利用的时候一般是用来修改函数调用时候的this指向的。比如我们看下面的这个例子： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="test"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;//var getId = document.getElementById;var getId = function(id)&#123; return document.getElementById(id);&#125;getId('test');&lt;/script&gt;&lt;/html&gt; 这里是可以得到id为test的标签的，但是如果将getID换成注释中的那句话的时候，这时候在大多数浏览器中就会报错。这是因为如果在很多浏览器里面，getElementById这个方法内部实现需要this，这个this应该是指向document。当getElementById作为document的属性被调用的时候，方法内部的this确实是指向document的。但如果getId引用了document.getElementById之后，再去调用函数的话，就成了普通的函数调用，函数里面的this就指向了windows而不是document。 我们可以利用apply来实现这个调用的过程： 1234567document.getElementById = (function(func)&#123; return function()&#123; return func.apply(document,arguments) &#125;&#125;)(document.getElementById)var getId = document.getElementById;getId('test'); 这时候利用apply这个函数，将this所指向的对象指向了document，就能够实现原来的功能了。 利用apply和call可以修正我们函数的this，比如下面这个例子： 1234567document.getElementById('test').onclick = function(func)&#123; console.log(this.id); var func = function()&#123; console.log(this) &#125; func()&#125; 在这个例子中，外层的console.log能够正常输出test，但是内部函数输出的却是undefined，这时候如果还想让内部的函数像外部的函数一样正常输出的话，就需要利用apply来调用函数。 1234567document.getElementById('test').onclick = function(func)&#123; console.log(this.id); var func = function()&#123; console.log(this) &#125; func.call(this)&#125; 2.利用Function.prototype.bind来指定函数内部的this 大部分的浏览器都实现了Function.prototype.bind这个函数用来指定Function的this指向。下面的这个例子用来模拟这个过程。 123456789101112131415Function.prototype.bind = function(context)&#123; var self = this; return function()&#123; return self.apply(context,arguments); &#125;&#125;var obj = &#123; name:"Jone"&#125;var func = function()&#123; console.log(this.name)&#125;.bind(obj);func(obj) 在定义Function.prototype.bind的时候，context就是我们想要修正的this对象。在函数体内，首先我们先用一个self对象将函数的引用保存起来，之后返回一个函数，这个函数就是在我们调用func()的时候被执行的。在函数的内部，self.apply才是执行原来的func函数，并且指定了context是这个函数的this。 3.借用其他对象的方法]]></content>
      <categories>
        <category>javascript设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js异步编程——async的用法]]></title>
    <url>%2F2018%2F11%2F03%2Fjs%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94async%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[生成器的简单回顾出现的问题​ 在生成器的时候，我们说可以利用生成器的方式去完成一段异步回调。这样的话可以避免多个promise对象的级联造成代码的冗杂和难以维护。但是在运用生成器的时候，下面的这段代码会出现问题： 123456789101112131415161718192021222324const readFile = function () &#123; return new Promise(function (resolve, reject) &#123; setTimeout(()=&gt;&#123; console.log('aaaa') resolve('hhh') &#125;,1000) &#125;);&#125;;const gen = function* () &#123; const f1 = yield readFile(); const f2 = yield readFile(); console.log(f1); console.log(f2);&#125;;var test = gen()test.next();test.next();test.next();//运行的结果是：// undefined// undefined// aaaa// aaaa 解决的方案​ 可以看到，上面的这段代码本来我们预期的结果应该是等到前面的异步代码执行命完毕之后再执行同步代码。但是这个时候由于我们连续调用了三次next方法，这时候同步的操作被先执行了。这是有问题的，我们需要在异步操作之后再进行后面的操作，如果非要用生成器来实现的话，可以用下面的方式来解决： 123456789101112131415161718192021222324252627282930313233343536const readFile = function () &#123; return new Promise(function (resolve, reject) &#123; setTimeout(()=&gt;&#123; console.log('aaaa') resolve('hhh') &#125;,2000) &#125;);&#125;;const gen = function* () &#123; const f1 = yield readFile(); const f2 = yield readFile(); console.log(f1); console.log(f2);&#125;;var test = gen()test.next = (function(func)&#123; return function()&#123; var obj = func.apply(test,arguments); var aa = obj.value; if(obj.done) return; if(aa instanceof Promise)&#123; // console.log('这是一个异步操作') aa.then((args)=&gt;&#123; console.log(args) test.next() return args; &#125;) &#125;else&#123; // console.log('这是一个同步操作') test.next() &#125; &#125;&#125;)(test.next)test.next(); ​ 这样的话发现代码是按照正常的顺序执行了，但是还是有个问题，我们的f1和f2的返回值还是一个undefined，这是因为上面的函数很难返回一个值，如果非要这样的话目前我想到的办法是在生成器中声明一个对象，在每次执行异步操作的时候都传入这个参数，并且每次都会去改变对应的值，这样的话就能够实现上述功能： 1234567891011121314151617181920212223242526272829303132333435363738394041const readFile = function (args) &#123; return new Promise(function (resolve, reject) &#123; setTimeout(()=&gt;&#123; console.log('aaaa') args.f1 = 2 args.f2 = 32 resolve('hhh') &#125;,1000) &#125;);&#125;;const gen = function* () &#123; var canshu = &#123; f1:undefined, f2:undefined &#125; yield readFile(canshu); yield readFile(canshu); console.log(canshu.f1); console.log(canshu.f2);&#125;;var test = gen()test.next = (function(func)&#123; return function()&#123; var obj = func.apply(test,arguments); var aa = obj.value; if(obj.done) return; if(aa instanceof Promise)&#123; // console.log('这是一个异步操作') aa.then((args)=&gt;&#123; test.next() return args; &#125;) &#125;else&#123; // console.log('这是一个同步操作') test.next() &#125; &#125;&#125;)(test.next)test.next(); ​ 上述代码是我们运用生成器来写的一个按正常代码顺序执行混合异步和同步操作的一个例子。实质是如果当前的操作是一个异步操作，那么他的下一个操作是放在他的Promise对象中的then方法里的，只有在当前的异步操作执行完毕的时候才会进行后续的操作。但是如果当前的操作是个同步的操作。那么就直接执行后续的操作，这样就实现了我们正常的代码顺序。 通过async实现的方法一个实例​ 但是可以看得出，由生成器来解决异步问题，需要我们自己去改写Next方法，代码比较复杂，并且返回参数的时候是不容易的。为了更简单的操作异步程序，ES7语法为我们提供了一个更简单的操作方式——使用async来处理。实际上async就是Generator的语法糖。现在我们用async来写刚刚我们的异步操作的例子，可以得到： 123456789101112131415const setFunc = function asyncFunction(args1)&#123; return new Promise((resolve) =&gt; &#123; setTimeout(()=&gt;&#123; console.log('nihao') resolve(args1) &#125;,1000) &#125;)&#125;const gen =async function() &#123; const f1 = await setFunc('this is f1'); console.log(f1); const f2 = await setFunc('this is f2'); console.log(f2);&#125;;var test = gen() ​ 首先这里定义了一个异步的函数setFunc()，之后对这个setFunc进行一些操作，这个函数返回了一个Promise对象，其中进行了一些异步的操作。之后用await执行这个异步的操作，之后在异步操作之后进行了一些同步的操作最后的输出结果表明，在async函数里，通过await声明的函数可以进行相关的异步操作，并且后面的操作会等到这个异步操作结束之后进行，实质是根据生成器的原理进行的相关操作。 async函数返回值​ async函数返回的是一个Promise对象，其内部的return语句会被认为是调用了resolve函数，返回值即是这个函数的参数。同样，在async函数里面也可以抛出一个异常，会使得Promise调用reject函数并catch住这个异常。 1234567891011121314async function f1()&#123; return 'func1'&#125;async function f2()&#123; throw new Error('Something error')&#125;f1().then((args)=&gt;&#123; console.log('this is ' + args)&#125;)f2().then((args)=&gt;&#123; console.log('this is ' + args)&#125;,(args)=&gt;&#123; console.log('this is an error\n' + args)&#125;) await命令​ await一般后面跟的是一个Promise对象，如果不是的话就会返回对应的值。 ​ 尤其需要注意的是，如果await后面的Promise对象是reject，那么就会给回调函数中的catch接收，但是这里的问题就是，如果前面出现了reject，对应后面的内容就不能执行了。这时候就需要在await的异步操作后面加上catch操作，从而进行异常的处理。 12345678910const gen =async function() &#123; const f1 = await setFunc('this is f1').catch(()=&gt;&#123; console.log('test1') &#125;); console.log(f1); const f2 = await setFunc('this is f2').catch(()=&gt;&#123; console.log('test2') &#125;); console.log(f2);&#125;; 使用的注意点####同时进行异步操作 ​ 由于await实际上是将异步转化成同步的一种方式，对于几个相互独立的异步操作，应该让其同时进行异步操作，而不应该用await让被一个进程阻塞其他进程的进行，这样会十分耗时。应该用下面的两种写法让他们同时执行： 123456789101112131415161718192021const setFunc1 = function asyncFunction(args1)&#123; return new Promise((resolve,reject) =&gt; &#123; setTimeout(()=&gt;&#123; console.log('nihao') resolve(args1) &#125;,1000) &#125;)&#125;const setFunc2 = function asyncFunction(args1)&#123; return new Promise((resolve,reject) =&gt; &#123; setTimeout(()=&gt;&#123; console.log('nihao') resolve(args1) &#125;,1000) &#125;)&#125;const gen2 = async function()&#123; const [f1,f2] = await Promise.all([setFunc1(),setFunc2()]) console.log('this is the end')&#125;gen2() 当然，如果非要用await，上面的代码也可以转化成一下的代码： 1234let fooPromise = getFoo();let barPromise = getBar();let foo = await fooPromise;let bar = await barPromise; 两者都是等效的，都可以让多个独立的异步操作在同一时间进行。 在普通函数中首先await必须要在async声明的函数里面，否则会报错。首先看下面的这个例子： 123456789101112131415161718function myPost(data)&#123; return new Promise((resolve)=&gt;&#123; setTimeout(()=&gt;&#123; console.log('This is ' + data) &#125;,1000) &#125;)&#125;function myTest()&#123; const docs = [ &#123;aa:'ss'&#125;, &#123;bb:'uu'&#125;, &#123;cc:'oo'&#125; ] docs.forEach(async function(doc)&#123; await myPost(JSON.stringify(doc)) &#125;)&#125;myTest() 这样写的await运行出来的结果一般都不是我们期望的，一个结束之后在运行另外一个，而是三个同时在运行，是并发执行。正确的方式应该是： 12345678910111213141516171819function myPost(data)&#123; return new Promise((resolve)=&gt;&#123; setTimeout(()=&gt;&#123; console.log('This is ' + data) resolve() &#125;,1000) &#125;)&#125;async function myTest()&#123; const docs = [ &#123;aa:'ss'&#125;, &#123;bb:'uu'&#125;, &#123;cc:'oo'&#125; ] for(let doc of docs)&#123; await myPost(JSON.stringify(doc)) &#125;&#125;myTest() ​ 注意在每个异步操作里面都应该加上resolve()，不然程序只会输出JSON数据的第一项之后就不再输出。如果这时候确实有一个需求是前面需要并发地执行几个操作，后面再对他们的结果进行一些处理的话，这时候就需要用下面的两种写法来实现： 123456789101112131415161718192021async function test()&#123; let obj = [ &#123;name:'liming'&#125;, &#123;age:18&#125;, &#123;sex:'man'&#125; ] let promises = obj.map((bd) =&gt; myPost(JSON.stringify(bd))); await Promise.all(promises); console.log('This is the end')&#125;//第二种写法async function test()&#123; let obj = [ &#123;name:'liming'&#125;, &#123;age:18&#125;, &#123;sex:'man'&#125; ] let promises = obj.map((bd) =&gt; myPost(JSON.stringify(bd))); await Promise.all(promises); console.log('This is the end')&#125; 顶层await​ 目前，esm模块加载器支持顶层await，即这时候await命令可以不放在async函数内，直接使用即可。但是这种写法的脚本必须使用esm加载器，否则不能执行。]]></content>
      <categories>
        <category>web基础知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js——Vuex相关用法]]></title>
    <url>%2F2018%2F11%2F03%2Fjs%E2%80%94%E2%80%94Vuex%E7%9B%B8%E5%85%B3%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[js——Vuex相关用法 平时在一个vue组件中，里面的数据和方法只有在但当前的.vue组件中可以访问和使用，其他的组件是无法访问的。但是在实际的业务逻辑中，经常有跨组件数据的需求，因此，Vuex的设计就是为了用来统一管理组件状态的。它定义了一系列的规范来使用和操作数据，使组件应用更加高效。 Vuex的基本用法： 首先通过NPM安装Vuex： npm install –save vuex 在main.js中通过Vue.use()使用Vuex： store包含了应用的数据（状态）和操作过程。任何组件使用同一store的操作的数据时，只要store的数据发生变化，对应的组件也会立刻更新。 在任何组件内，可以直接通过$store.state.count 读取这个数据： 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div class="hello"&gt; &lt;p&gt;&#123;&#123;$store.state.count&#125;&#125;&lt;/p&gt; &lt;button @click="handleIncrement"&gt;+1&lt;/button&gt; &lt;button @click="handleDecrease"&gt;-1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'HelloWorld', data () &#123; return &#123; msg: 'Welcome to Your Vue.js App' &#125; &#125;, methods:&#123; handleIncrement () &#123; this.$store.commit('increment'); &#125;, handleDecrease () &#123; this.$store.commit('decrease'); &#125; &#125;&#125;&lt;/script&gt; 当然，以上$store.state.count亦可以换成count，然后后面加上： 12345computed:&#123; count()&#123; return this.$store.state.count; &#125; &#125; 在组件内，来自store的数据只能读取，不能手动改变，改变store数据的唯一途径就是显式的提交mutatations。他是Vuex的第二个选项，用来直接修改state里的数据。 Vuex还有其他的三个选项可以使用：getters、actions、modules。 123456789101112131415161718getters:&#123; getNum:state =&gt; &#123; return state.list.filter(item =&gt; item &lt; 10); &#125;, listCount:(state,getters) =&gt; &#123; return getters.getNum.length; &#125; &#125;//.vue文件中computed:&#123; count()&#123; return this.$store.state.count; &#125;, listCount () &#123; return this.$store.getters.listCount; &#125; &#125; 这里，getter也可以依赖于其他的getter，把getter作为第二个参数。如上例中的listCount。 注意的是，mutation里面不应该出现异步操作的数据，因此有了actions，他和mutation很像，但是提交的是mutation，并且可以异步操作业务逻辑。 action在组件中通过$store.dispatch触发，例如使用action加一： 123456789101112131415//main.jsactions:&#123; increment (context) &#123; context.commit('increment') &#125; &#125; //.vue methods:&#123; handleIncrement () &#123; this.$store.dispatch('increment'); &#125;, handleDecrease () &#123; this.$store.commit('decrease'); &#125; &#125;, 下面是处理异步操作的代码： 12345678910111213141516171819202122//main.jsactions:&#123; increment (context) &#123; return new Promise(resolve =&gt;&#123; setTimeout(()=&gt;&#123; context.commit('increment'); resolve(); &#125;,1000) &#125;) &#125; &#125; //.vue methods:&#123; handleIncrement () &#123; this.$store.dispatch('increment').then(()=&gt;&#123; console.log(this.$store.state.count) &#125;); &#125;, handleDecrease () &#123; this.$store.commit('decrease'); &#125; &#125;, mutation和actions看起来很相似，但一般涉及改变数据的时候用Vue，存在业务逻辑的时候用actions。 最后一个是module，主要是用来将store分割到不同的模块，微地就是让main.js中的store看起来更友好。 12345678910111213141516171819202122232425262728var moduleA = &#123; state:&#123; count:0 &#125;, mutations:&#123; hello()&#123; console.log('hello') &#125; &#125;&#125;var moduleB = &#123; state:&#123; count:1 &#125;, mutations:&#123; get(state)&#123; console.log('state=' + state.count) &#125; &#125;&#125;const store = new Vuex.Store(&#123; modules:&#123; a:moduleA, b:moduleB &#125;&#125;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[computed和watch]]></title>
    <url>%2F2018%2F11%2F03%2F%E4%B8%80%E3%80%81computed%E7%9B%B8%E5%85%B3%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[一、computed相关的用法说明先看下面这行代码的效果： 123456789101112131415161718192021222324252627282930import Vue from 'vue'new Vue(&#123; el:'#root', template:` &lt;div&gt; &lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;getname()&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;number&#125;&#125;&lt;/div&gt; &lt;input type="text" v-model="number"/&gt; &lt;/div&gt; `, data:&#123; firstname:'Jone', lastname:'Lou', number:0 &#125;, computed:&#123; name()&#123; console.log('new name') return `$&#123;this.firstname&#125; $&#123;this.lastname&#125;` &#125; &#125;, methods:&#123; getname()&#123; console.log('new name invoke') return `$&#123;this.firstname&#125; $&#123;this.lastname&#125;` &#125; &#125;&#125;) ​ 这里在computed中声明了一个name()方法和getname()方法，在改变输入框的值时候，整个应用的值是会被重新渲染的，可以发现computed中的方法并没有被触发，但是getname()中的方法被触发了。这对性能的优化是很有效的。但是并不是改变的时候都不会触发。如果这个时候在template中加上： 12&lt;input type="text" v-model="firstname"/&gt; &lt;input type="text" v-model="lastname"/&gt; 并且在输入框中改变输入的值的时候，就会看见input中的值改变了computed中的方法被触发了。这是当它依赖的值被改变的时候它的计算属性会被调用。 当然，computed还可以做一些属性的设置： 1234567891011121314computed:&#123; name:&#123; get()&#123; console.log('new name'); return `$&#123;this.firstname&#125; $&#123;this.lastname&#125;` &#125;, set(name)&#123; const names = name.split(' ') this.firstname = names[0] this.lastname = names[1] console.log('hhh') &#125; &#125; &#125;, 这里可以对name设置get和set方法从而实现读取的相关操作。 二、watchwatch可以对一个变量的值的变化进行监听，并做一些响应的操作。这里我们对firstname及逆行一次监听： 12345watch:&#123; firstname(newname,oldname)&#123; this.fullname = newname+" "+this.lastname &#125;&#125;, 这里引入了一个新的变量叫fullname，并且在上面的div中对其进行渲染，可以看见，刚开始打开的时候并不能看见fullname的值，这是因为watch方法最初绑定的时候是不会被渲染的，只有被监听的值发生变化的时候才会被执行。当然我们也可以对其进行一些处理： 12345678watch:&#123; firstname:&#123; handler(newname,oldname)&#123; this.fullname = newname+" "+this.lastname &#125;, immediate:true &#125;&#125; 这样在初始化的时候就可以将数据渲染到页面上了。watch不适合用来做数据的显示，但适合见町名数据的变化并在后台做一些相关的处理。 当然，watch还有一个属性叫做deep这里做一个例子： 123456789101112//data obj:&#123; a:'123' &#125; //watchobj:&#123; handler(newname,oldname)&#123; console.log('obj.a changed') &#125;, immediate:true, //deep:true &#125; ​ 这里，如果在输入框中仅仅改变obj.a的值的时候，watch里面的方法并不会被触发，这是因为对象中的watch只会监听对象的变化，但是改变内部的属性是不起作用的。常用的办法就是加上deep:true。但这里也会有一个问题，每当对象中的属性发生变化的时候，不管和a这个属性有关还是无关，都会触发这个方法，这对性能是有影响的。一个好的处理办法就是将监听的obj换成字符串的’obj.a’。这时候就会只监听a属性。同时注意，在computed中不要对监听值进行修改，不然可能会导致无限次触发。]]></content>
  </entry>
  <entry>
    <title><![CDATA[组件的继承]]></title>
    <url>%2F2018%2F11%2F03%2Ftitle%20computed%E5%92%8Cwatch%2F</url>
    <content type="text"><![CDATA[1、组件的继承 通过组件的继承我们可以利用已定义的组件的一些特性。首先先看第一种定义的方式： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import Vue from 'vue'const component = &#123; // props:['active','propOne','onChange'], props:&#123; active:Boolean, propOne:&#123; require:true &#125; &#125;, template:` &lt;div&gt; &lt;input type="text" v-model="text"&gt; &lt;span @click="handleChange"&gt;&#123;&#123;propOne&#125;&#125;&lt;/span&gt; &lt;span v-show="active"&gt;show&lt;/span&gt; &lt;/div&gt; `, data()&#123; return &#123; text:0 &#125; &#125;, mounted()&#123; console.log('comp instance'); &#125;, methods:&#123; handleChange()&#123; //this.onChange() this.$emit('change') &#125; &#125;&#125;const CompVue = Vue.extend(component)new CompVue(&#123; el:'#root', propsData:&#123; propOne:123, active:true &#125;, data()&#123; return &#123; text:123 &#125; &#125;, mounted()&#123; console.log('this instance'); &#125;&#125;) ​ 在这个里面，CompVue继承了名为component这样的一个组件，并且在里面实现了自己的一些方法。首先，如果这个时候需要和被继承组件中的子组件通信的时候，需要利用propsData进行传递，利用原来的props是没有效果的。然后就是在继承的组件当中，data会自动覆盖掉原先的data。但是对于mounted而言是不会被覆盖的，而是先执行被继承对象中的mounted方法，再调用自己的mounted方法。 当然，还有一种定义继承的方式： 12345678910111213141516const comp2 = &#123; extends:component, data()&#123; return&#123; text:555 &#125; &#125;&#125;new Vue(&#123; el:'#root', components:&#123; comp:comp2 &#125;, template:`&lt;comp&gt;&lt;/comp&gt;`&#125;) 二、组件的parent利用$parent这个变量可以找到一个组件的父组件，并且通过this. $parent.$options.name可以查到他父组件的名字。 1234567891011121314151617181920212223242526272829const comp2 = &#123; extends:component, data()&#123; return&#123; text:555 &#125; &#125;, mounted()&#123; console.log(this.$parent.$options.name) &#125;&#125;new Vue(&#123; name:&apos;myTest&apos;, el:&apos;#root&apos;, components:&#123; comp:comp2 &#125;, data()&#123; return &#123; text:2333 &#125; &#125;, template:` &lt;div&gt; &lt;span&gt;&#123;&#123;text&#125;&#125;&lt;/span&gt; &lt;comp&gt;&lt;/comp&gt; &lt;/div&gt;`&#125;) 当然，也可以通过$parent来改变响应的值。但是尽量不要去这样做。父组件也是可以进行设置的： 12345678910111213141516const parent = new Vue(&#123; name:'parent'&#125;)const comp2 = &#123; parent:parent, extends:component, data()&#123; return&#123; text:555 &#125; &#125;, mounted()&#123; console.log(this.$parent.$options.name) &#125;&#125; 这样声明是没有用的，结果还将是parent为调用该组件的名称，这时候想要定义父组件必须在new一个Vue的时候声明才有效果。 接下来看一个多层调用的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import Vue from 'vue'const childComponents = &#123; template:` &lt;div&gt;child child &#123;&#123;value&#125;&#125;&lt;/div&gt; `, inject:['yeye','value'], mounted()&#123; console.log(this.yeye) &#125;&#125;const component = &#123; props:&#123; active:Boolean, propOne:&#123; require:true &#125; &#125;, data()&#123; return &#123; text:0, style:&#123; width:'200px', height:'200px', border:'1px black solid' &#125; &#125; &#125;, mounted()&#123; console.log('comp instance'); &#125;, components:&#123; childComponents &#125;, template:` &lt;div :style="style"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;child-components&gt;&lt;/child-components&gt; &lt;/div&gt; `&#125;new Vue(&#123; name:'myTest', el:'#root', components:&#123; comp:component &#125;, provide()&#123; return&#123; yeye:this, value:this.value &#125; &#125;, data()&#123; return &#123; text:2333, value:222222 &#125; &#125;, mounted()&#123; // console.log(this.$parent.$options.name) &#125;, template:` &lt;div&gt; &lt;comp&gt; &lt;span&gt;&#123;&#123;text&#125;&#125;&lt;/span&gt; &lt;/comp&gt; &lt;input type="text" v-model="value"/&gt; &lt;/div&gt;`&#125;) 但是是没有办法访问越级的组件的，这个时候就需要去做一些处理。 首先在”爷爷辈“的组件中，声明一个provide方法，这样才会在Vue对象初始化的过程中得到里面的值。 123456provide()&#123; return&#123; yeye:this, value:this.value &#125; &#125;, 然后在”孙子辈“里面再去利用inject调用： 123456789const childComponents = &#123; template:` &lt;div&gt;child child &#123;&#123;value&#125;&#125;&lt;/div&gt; `, inject:['yeye','value'], mounted()&#123; console.log(this.yeye) &#125;&#125; 但是这时候，如果在input中输入一个数的话，孙子中绑定的值是不会变化的，这是因为默认情况下provide是不提供Vue的react属性的，可以做下面的处理： 1234567891011provide()&#123; const data = &#123;&#125; Object.defineProperty(data,'value',&#123; get: ()=&gt; this.value, enumerable:true &#125;) return&#123; yeye:this, data &#125; &#125;, 也就是子组件在每次访问value这个属性的时候，实际上是在访问get方法，然后访问到value值的变化，这也就是Vue实现的一个原理，但是Vue官方文档中可能之后会被移除。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack]]></title>
    <url>%2F2017%2F02%2F22%2F%E5%89%8D%E7%AB%AF11_2%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94webpack%2F</url>
    <content type="text"><![CDATA[前端11_2笔记——webpack 安装webpack配置 首先在新建的项目中npm init新建一个npm项目，然后安装webpack相关的组件 1npm i webpack vue vue-loader 同时还需要安装： 1npm i css-loader vue-template-compiler 新建一个app.vue并写入一些组件，新建一个webpack.config.js进行一些设置。 新建一个index.js进行入口文件的设置 1234567891011import Vue from 'vue'import App from './app.vue'import './styles/test.css'import './styles/test-stylus.styl'const root = document.createElement('div');document.body.appendChild(root);new Vue(&#123; render:(h) =&gt; h(App)&#125;).$mount(root) webpack只支持js文件并且只支持ES5的语法，所以需要进行一些处理： 12345678module:&#123; rules:[ &#123; test:/\.vue$/, loader:'vue-loader' &#125; ] &#125;, 并且vue-loader在15.*之后的版本都是 vue-loader的使用都是需要伴生 VueLoaderPlugin的，具体内容可详见https://vue-loader.vuejs.org/guide/#vue-cli 所以进行以以下处理： 123456789101112131415161718// webpack.config.jsconst VueLoaderPlugin = require('vue-loader/lib/plugin')module.exports = &#123; module: &#123; rules: [ // ... other rules &#123; test: /\.vue$/, loader: 'vue-loader' &#125; ] &#125;, plugins: [ // make sure to include the plugin! new VueLoaderPlugin() ]&#125; 之后运行npm run dev就能够看见新建了一个dist的文件，并且底下有一个bundle.js文件，webpack所作的工作就是把不同的的静态资源文件打包成一个.js文件，然后在html中去引入这个文件实现。因为在http中将零散的文件打包成一个减少http请求的次数。 1.处理.vue文件 在webpack.config.js文件中，利用module来设置rules： 1234&#123; test:/\.vue$/, loader:'vue-loader'&#125; 2.处理CSS文件 利用css-loader来处理CSS文件，但是在实际运用的过程当中会有不同的处理方式，所以这时候需要换一种写法： 12 最终，CSS代码会写入到js文件中去，并且最终会引入到html当中去。 3.图片的处理方式 这里loader使用一个对象去写，因为实际上一个对象是可以进行配置的，利用options可以对其进行配置： 这里，url-loader可以将图片转换为Base-64代码直接插入到js中去，不用生成新的图片，这对于我们几KB的文件是很有用的，就不用生成http请求。url-loader实际上封装了file-loader，其就是将图片进行读取并进行一些简单的操作之后重新存储。limit设置了转换图片的大小。 12345loader:'url-loader',options:&#123; limit:1024, name:'[name]-aaa.[ext]'&#125; 配置之后需要安装相应的模块： 1npm i style-loader url-loader file-loader 4.CSS CSS预处理器就是用模块化的思想去写CSS代码。比如利用.styl 12345678&#123; test:/\.styl/, use:[ 'style-loader', 'css-loader', 'stylus-loader' ]&#125; 并安装stylus和stylus-loader 配置webpack-dev-server首先安装这个包 1npm i webpack-dev-server 在package.json中的scripts加入”dev”:”webpack-dev-server –config webpack.config.js” 然后在webpack.config.js中全局加入target:’web’，同时需要判断正式环境和开发环境： 安装cross-env可以保证我们在不同的平台执行同一个脚本,在package.json中的build下加入 12"build": "cross-env NODE_ENV=production webpack --config webpack.config.js","dev": "cross-env NODE_ENV=development webpack-dev-server --config webpack.config.js" 当启动脚本的时候设置的环境变量全部都是设置在process.env里面的，可以在process.env中设置多个变量名并读取到这些变量。 然后设置当环境为production的时候，进行对server的配置： 1234567891011if(isDev)&#123; config.devServer = &#123; port:'8000', //设置成0.0.0.0好处是可以通过内网的IP进行访问，而localhost就不行 host:'0.0.0.0', //当编译有错误的时候，可以将我们的错误显示到我们的网页上 overlay:&#123; errors:true &#125; &#125;&#125; 现在需要一个html页面来显示我们的内容： 首先安装一个插件： 1npm i html-webpack-plugin 之后在最前面引入这个插件： 1const HTMLPlugin = require('html-webpack-plugin') 并进行调用： 123456789101112plugins: [ // make sure to include the plugin! new VueLoaderPlugin(), new HTMLPlugin(), //这个是用来给wewbpack在编译的时候和js代码运行时判断环境 //提供相关的框架去区分打包 new webpack.DefinePlugin(&#123; 'process.env':&#123; NODE_ENV:isDev ? '"development"' : '"production"' &#125; &#125;) ] 热加载在config.devServer中设置 1hot:true, 然后设置下面的两个选项： 1234config.plugins.push( new webpack.HotModuleReplacementPlugin(), new webpack.NoEmitOnErrorsPlugin() ) 并在前面引入webpack： 1const webpack = require('webpack') 并且设置devtool 1234//这是帮助我们调试代码 //利用sourcemap进行代码的映射，在浏览器中打开的还是我们正常写的代码。 //提高效率和准确性 config.devtool = '#cheap-module-eval-source-map' 最终，在webpack.config.js中的代码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384‘const path = require('path')const VueLoaderPlugin = require('vue-loader/lib/plugin')const HTMLPlugin = require('html-webpack-plugin')const webpack = require('webpack')const isDev = process.env.NODE_ENV === 'development'const config = &#123; target:'web', entry:path.join(__dirname,'src/index.js'), output:&#123; filename:'bundle.js', path:path.join(__dirname,'dist') &#125;, module:&#123; rules:[ &#123; test:/\.vue$/, loader:'vue-loader' &#125;,&#123; test:/\.css$/, use:[ 'style-loader', 'css-loader' ] &#125;,&#123; test:/\.(gif|jpg|jpeg|png|svg)$/, use:[ &#123; loader:'url-loader', options:&#123; limit:1024, name:'[name]-aaa.[ext]' &#125; &#125; ] &#125;,&#123; test:/\.styl/, use:[ 'style-loader', 'css-loader', 'stylus-loader' ] &#125; ] &#125;, plugins: [ // make sure to include the plugin! new VueLoaderPlugin(), new HTMLPlugin(), //这个是用来给wewbpack在编译的时候和js代码运行时判断环境 //提供相关的框架去区分打包 new webpack.DefinePlugin(&#123; 'process.env':&#123; NODE_ENV:isDev ? '"development"' : '"production"' &#125; &#125;) ]&#125;if(isDev)&#123; //这是帮助我们调试代码 //利用sourcemap进行代码的映射，在浏览器中打开的还是我们正常写的代码。 //提高效率和准确性 config.devtool = '#cheap-module-eval-source-map' config.devServer = &#123; port:'8000', //设置成0.0.0.0好处是可以通过内网的IP进行访问，而localhost就不行 host:'0.0.0.0', //当编译有错误的时候，可以将我们的错误显示到我们的网页上 overlay:&#123; errors:true &#125;, //每次编译完成后都会打开浏览器 //open:true //hot不会重新加载页面而是直接渲染组件。 hot:true, &#125; config.plugins.push( new webpack.HotModuleReplacementPlugin(), new webpack.NoEmitOnErrorsPlugin() )&#125;module.exports = config; CSS分离： 之前的CSS代码在打包之后都是在同一个.js文件中，并且里面内容很多不容易找到，这时候需要利用相关的插件对CSS进行分离。 首先先npm i extract-text-webpack-plugin 然后在webpack.config.js文件中添加const ExtractPlugin = require(‘extract-text-webpack-plugin’)，这个就是将我们的非js代码单独打包成一个文件，因为这个文件有可能会作为缓存和利用js将一些样式写入页面中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130const path = require(&apos;path&apos;)const VueLoaderPlugin = require(&apos;vue-loader/lib/plugin&apos;)const HTMLPlugin = require(&apos;html-webpack-plugin&apos;)const webpack = require(&apos;webpack&apos;)const ExtractPlugin = require(&apos;extract-text-webpack-plugin&apos;)const isDev = process.env.NODE_ENV === &apos;development&apos;const config = &#123; target:&apos;web&apos;, entry:path.join(__dirname,&apos;src/index.js&apos;), output:&#123; filename:&apos;bundle.js&apos;, path:path.join(__dirname,&apos;dist&apos;) &#125;, module:&#123; rules:[ &#123; test:/\.vue$/, loader:&apos;vue-loader&apos; &#125;, &#123; test:/\.jsx$/, loader:&apos;babel-loader&apos; &#125;, &#123; test:/\.(gif|jpg|jpeg|png|svg)$/, use:[ &#123; loader:&apos;url-loader&apos;, options:&#123; limit:1024, name:&apos;[name]-aaa.[ext]&apos; &#125; &#125; ] &#125; ] &#125;, plugins: [ // make sure to include the plugin! new VueLoaderPlugin(), new HTMLPlugin(), //这个是用来给wewbpack在编译的时候和js代码运行时判断环境 //提供相关的框架去区分打包 new webpack.DefinePlugin(&#123; &apos;process.env&apos;:&#123; NODE_ENV:isDev ? &apos;&quot;development&quot;&apos; : &apos;&quot;production&quot;&apos; &#125; &#125;) ]&#125;if(isDev)&#123; config.module.rules.push(&#123; test:/\.css$/, use:[ &apos;style-loader&apos;, &apos;css-loader&apos; ] &#125;,&#123; test:/\.styl/, use:[ &apos;style-loader&apos;, &apos;css-loader&apos;, &#123; loader:&apos;postcss-loader&apos;, options:&#123; sourceMap:true, &#125; &#125;, &apos;stylus-loader&apos; ] &#125;) //这是帮助我们调试代码 //利用sourcemap进行代码的映射，在浏览器中打开的还是我们正常写的代码。 //提高效率和准确性 config.devtool = &apos;#cheap-module-eval-source-map&apos; config.devServer = &#123; port:&apos;8000&apos;, //设置成0.0.0.0好处是可以通过内网的IP进行访问，而localhost就不行 host:&apos;0.0.0.0&apos;, //当编译有错误的时候，可以将我们的错误显示到我们的网页上 overlay:&#123; errors:true &#125;, //每次编译完成后都会打开浏览器 //open:true //hot不会重新加载页面而是直接渲染组件。 hot:true, &#125; config.plugins.push( new webpack.HotModuleReplacementPlugin(), new webpack.NoEmitOnErrorsPlugin() )&#125; else&#123; config.output.filename = &apos;[name].[chunkhash:8].js&apos; config.module.rules.push(&#123; test:/\.styl/, use:ExtractPlugin.extract(&#123; fallback:&apos;style-loader&apos;, use:[ &apos;css-loader&apos;, &#123; loader:&apos;postcss-loader&apos;, options:&#123; sourceMap:true, &#125; &#125;, &apos;stylus-loader&apos; ] &#125;) &#125;,&#123; test:/\.css$/, use:ExtractPlugin.extract(&#123; fallback:&apos;style-loader&apos;, use:[ &#123; use:[ &apos;css-loader&apos; ] &#125; ] &#125;) &#125;) config.plugins.push( new ExtractPlugin(&apos;styles.[contentHash:8]&apos;) )&#125;module.exports = config;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
</search>
