<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js代理]]></title>
    <url>%2F2018%2F11%2F04%2Fjs%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[1.使用代理控制访问 2.使用代理的优化代码 2.1简单的说明 2.2node中运行代码的不同探究 2.3原因解释 1、使用代理控制访问 ​ 代理是ES6语法提出的，是我们通过代理控制对另一个对象的访问。可以将代理理解为通用化的setter和getter方法，区别就是每个setter和getter只能控制单个对象的属性，而代理可用于对象交互的通用处理，包括调用对象的方法。首先先看下面的这个例子。 1234567891011121314151617181920212223242526272829303132const people = &#123; name:'liming'&#125;const father = new Proxy(people,&#123; get:(target,key) =&gt; &#123; console.log(target[key]) if(key in target) return target[key] else&#123; console.log('The value do not exits'); return undefined; &#125; &#125;, set:(target,key,value) =&gt; &#123; console.log('Something changed'); target[key] = value; &#125;&#125;)console.log(father.name)father['name'] = "mingming"console.log(people.name)console.log(father.ta)// 执行结果// liming// liming// Something changed// mingming// undefined// The value do not exits// undefined 这里我们定义了一个people对象，并设置了他的代理father，并且在father中指定了getter和setter方法。首先先查看father的名称，这时候会触发father的getter并返回名称。如果这里在getter中不返回，在console.log返回将会是undefined。之后对father进行了赋值，调用了father的setter方法，并将target即people的name属性进行了重新设定。之后又对原来people中不存在的一个变量ta进行访问，这时候还会去调用getter方法，然后检查key不在target对象中的时候就会返回一个undefined。 2、使用代理的优化代码 简单的说明 使用代理同时还可以优化代码。在不使用代理的时候，对一个对象的设置需要进行很多次的defineProperty的设置，如果需要为一个对象添加很多属性的时候就显得很多。但是利用了代理就能够很方便的解决这些问题。 123456789101112131415161718192021222324252627282930313233343536function makeConstructor(target)&#123; return new Proxy(target,&#123; get:(target,property) =&gt;&#123; console.log('Get function invoked') return target[property]; &#125;, set:(target,property,value) =&gt; &#123; console.log('Set function invoked'); target[property] = value; &#125; &#125;)&#125;let peo = &#123;name:'Yoshi'&#125;peo = makeConstructor(peo);console.log('分割线1')console.log(peo.name)console.log('分割线2')peo.weapon = 'shui'console.log('分割线3')console.log(peo.weapon)console.log('分割线4')console.log(peo)// 运行结果：// 分割线1// Get function invoked// Yoshi// 分割线2// Set function invoked// 分割线3// Get function invoked// shui// 分割线4// Get function invoked// Get function invoked// Get function invoked 首先定义了一个构造器，使用了一个对象target作为被代理的对象。然后调用了makeConstructor来构造对象和代理之间的关系，并在makeConstructor返回了新建的代理，并设置了相关的一些方法。然后可以发现，最开始对象只有一个name属性，在访问的时候会触发getter方法并返回它的值。之后对peo对象中之前不存在的一个属性weapon进行了设置，这时候可以看见触发了setter方法，并在对象中添加了一个名为”weapon”属性。之后又查看了刚刚添加的weapon方法。在最后可以看见，我们console.log输出peo这个对象，结果发现调用了三次get方法。为了探究我们对get方法进行一些处理。 node中运行代码的不同探究 12345678910111213141516171819202122232425262728function makeConstructor(target)&#123; return new Proxy(target,&#123; get:(target,property) =&gt;&#123; //console.log(property) console.log('Get function invoked') return target[property]; &#125;, set:(target,property,value) =&gt; &#123; target[property] = value; &#125; &#125;)&#125;let peo = &#123;name:'Yoshi'&#125;peo = makeConstructor(peo);peo.weapon = 'shui'peo.weapon1 = 'shui'peo.weapon2 = 'shui'console.log(peo)// //运行的结果：// Get function invoked// Get function invoked// Get function invoked// &#123; name: 'Yoshi',// weapon: 'shui',// weapon1: 'shui',// weapon2: 'shui' &#125; 刚开始我的理解是在输出peo的时候，首先对peo这个类整体的访问会触发一次getter，之后对他里面的两个属性name和weapon访问取值的又是两次调用getter，这样就恰好三次。但是当我再增加几个属性的时候结果还是三次。然后就在get中每次输出property，可以看到下面的几个输出： 123Symbol(util.inspect.custom)inspectSymbol(Symbol.iterator) 原因解释 ​ 因为我是在node里面运行这个代码的，所以console.log出来的实际上是将这个对象进行了处理输出了对象中的属性。实际上在chrome浏览器的控制台中输入的话运行出来的结果应该是一个代理的对象。然后由于在node中对对象进行了一些处理，所以难免会对get进行调用从而将对象转化成可视的字符串类型。以上这些代码实际上都是对这个对象进行的一系列的操作。是node中util自带的一些模块，就是为了弥补JavaScript中原始方法的不足。 3.使用代理实现自动的填充属性 当我们拥有一个对象具有很长一串属性的时候，通常我们可以通过代理来生成它没有的属性，避免带妈妈的重复和繁重。 12345678910111213141516function Folder()&#123; return new Proxy(&#123;&#125;,&#123; get:(target,property)=&gt;&#123; if(!(property in target))&#123; target[property] = new Folder(); &#125; return target[property]; &#125; &#125;)&#125;const myFile = new Folder();try&#123; myFile.root.first.second.next = "aa.txt";&#125;catch(e)&#123; console.log('error')&#125; 在try中虽然myFile并没有后面的一系列属性，但当我们读取的时候会调用代理中的get方法帮我们创建，这样的话即使这个属性不存在也不会出现undefined的问题。 4.使用代理实现数组的负索引 ​ 在python等语言中，是允许使用负索引来查找对象的，但是JavaScript不允许这样做，但是通过代理的方法我们可以来模拟这个过程。 123456789101112131415161718192021function createArray(array)&#123; return new Proxy(array,&#123; get:(target,index) =&gt;&#123; index = +index return array[index &lt; 0 ? target.length + index : index]; &#125;, set:(target,index,value) =&gt; &#123; index = +index return array[index &lt; 0 ? target.length + index : index] = value &#125;&#125;)&#125;const test = ['hh','sss','llll','iii']const test2 = createArray(test)console.log(test2[-1]);console.log(test2[-3]);console.log(test[-1])//执行的结果是// iii// sss// undefined 这里通过一元运算符+将属性名变成了数值。然后在代理中对他们的负数情况进行了相应的处理。然后新建一个test的数组，并创建它的代理，通过代理可以用负索引来访问数组中的值。 5.代理的性能消耗 相比较正常访问对象而言，使用代理去访问性能会慢很多，比如上个例子中，使用代理访问数组相互比较正常访问数组而言。在Chrome上时间为正常的50倍，所以使用代理的时候还是需要谨慎。如果是在多性能不敏感的情况下使用。]]></content>
      <categories>
        <category>javascript高级特性</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js迭代器模式]]></title>
    <url>%2F2018%2F11%2F04%2Ftitle%20js%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[JavaScript迭代器 在JavaScript的框架Jquery中，&amp;.each是一个常用的迭代函数，通过这个each函数可以实现对一个数组的迭代。]]></content>
      <categories>
        <category>javascript高级特性</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js代理]]></title>
    <url>%2F2018%2F11%2F04%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1.保护代理和虚拟代理在前面的js学习中，ES6语法里有个proxy对象可以创建一个代理，可以通过代理实现控制不同权限的对象对目标对象的访问，从而实现对一些对象访问的过滤。虚拟代理的意思是，把一些开销大的对象，放在真正需要她的时候去创建。这是为了系统性能和一些特殊需要的考虑。由于js不容易判断是哪个对象访问了目标，所以JavaScript中不容易实现保护模式。常用的还是虚拟代理。 2.利用虚拟代理实现图片的预加载在web开发时，如果给一个图片直接设置一个src属性，常常会因为网络状况的异常导致图片无法正常加载。所以一般刚打开的时候会发现里面都是空白。为了解决这个问题一般就是会用一张预加载的图片占位，异步加载图片。一直等到图片加载完成之后就将其渲染到组件中去。]]></content>
      <categories>
        <category>javascript高级特性</category>
      </categories>
      <tags>
        <tag>JavaScript设计模式</tag>
        <tag>虚拟代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[apply和call的用法]]></title>
    <url>%2F2018%2F11%2F03%2Fcall%E5%92%8Capply%2F</url>
    <content type="text"><![CDATA[call和apply这两个方法在利用的时候一般是用来修改函数调用时候的this指向的。比如我们看下面的这个例子： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="test"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;//var getId = document.getElementById;var getId = function(id)&#123; return document.getElementById(id);&#125;getId('test');&lt;/script&gt;&lt;/html&gt; 这里是可以得到id为test的标签的，但是如果将getID换成注释中的那句话的时候，这时候在大多数浏览器中就会报错。这是因为如果在很多浏览器里面，getElementById这个方法内部实现需要this，这个this应该是指向document。当getElementById作为document的属性被调用的时候，方法内部的this确实是指向document的。但如果getId引用了document.getElementById之后，再去调用函数的话，就成了普通的函数调用，函数里面的this就指向了windows而不是document。 我们可以利用apply来实现这个调用的过程： 1234567document.getElementById = (function(func)&#123; return function()&#123; return func.apply(document,arguments) &#125;&#125;)(document.getElementById)var getId = document.getElementById;getId('test'); 这时候利用apply这个函数，将this所指向的对象指向了document，就能够实现原来的功能了。 利用apply和call可以修正我们函数的this，比如下面这个例子： 1234567document.getElementById('test').onclick = function(func)&#123; console.log(this.id); var func = function()&#123; console.log(this) &#125; func()&#125; 在这个例子中，外层的console.log能够正常输出test，但是内部函数输出的却是undefined，这时候如果还想让内部的函数像外部的函数一样正常输出的话，就需要利用apply来调用函数。 1234567document.getElementById('test').onclick = function(func)&#123; console.log(this.id); var func = function()&#123; console.log(this) &#125; func.call(this)&#125; 2.利用Function.prototype.bind来指定函数内部的this 大部分的浏览器都实现了Function.prototype.bind这个函数用来指定Function的this指向。下面的这个例子用来模拟这个过程。 123456789101112131415Function.prototype.bind = function(context)&#123; var self = this; return function()&#123; return self.apply(context,arguments); &#125;&#125;var obj = &#123; name:"Jone"&#125;var func = function()&#123; console.log(this.name)&#125;.bind(obj);func(obj) 在定义Function.prototype.bind的时候，context就是我们想要修正的this对象。在函数体内，首先我们先用一个self对象将函数的引用保存起来，之后返回一个函数，这个函数就是在我们调用func()的时候被执行的。在函数的内部，self.apply才是执行原来的func函数，并且指定了context是这个函数的this。 3.借用其他对象的方法]]></content>
      <categories>
        <category>javascript设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[组件的继承]]></title>
    <url>%2F2018%2F11%2F03%2Ftitle%20computed%E5%92%8Cwatch%2F</url>
    <content type="text"><![CDATA[1、组件的继承 通过组件的继承我们可以利用已定义的组件的一些特性。首先先看第一种定义的方式： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import Vue from 'vue'const component = &#123; // props:['active','propOne','onChange'], props:&#123; active:Boolean, propOne:&#123; require:true &#125; &#125;, template:` &lt;div&gt; &lt;input type="text" v-model="text"&gt; &lt;span @click="handleChange"&gt;&#123;&#123;propOne&#125;&#125;&lt;/span&gt; &lt;span v-show="active"&gt;show&lt;/span&gt; &lt;/div&gt; `, data()&#123; return &#123; text:0 &#125; &#125;, mounted()&#123; console.log('comp instance'); &#125;, methods:&#123; handleChange()&#123; //this.onChange() this.$emit('change') &#125; &#125;&#125;const CompVue = Vue.extend(component)new CompVue(&#123; el:'#root', propsData:&#123; propOne:123, active:true &#125;, data()&#123; return &#123; text:123 &#125; &#125;, mounted()&#123; console.log('this instance'); &#125;&#125;) ​ 在这个里面，CompVue继承了名为component这样的一个组件，并且在里面实现了自己的一些方法。首先，如果这个时候需要和被继承组件中的子组件通信的时候，需要利用propsData进行传递，利用原来的props是没有效果的。然后就是在继承的组件当中，data会自动覆盖掉原先的data。但是对于mounted而言是不会被覆盖的，而是先执行被继承对象中的mounted方法，再调用自己的mounted方法。 当然，还有一种定义继承的方式： 12345678910111213141516const comp2 = &#123; extends:component, data()&#123; return&#123; text:555 &#125; &#125;&#125;new Vue(&#123; el:'#root', components:&#123; comp:comp2 &#125;, template:`&lt;comp&gt;&lt;/comp&gt;`&#125;) 二、组件的parent利用$parent这个变量可以找到一个组件的父组件，并且通过this. $parent.$options.name可以查到他父组件的名字。 1234567891011121314151617181920212223242526272829const comp2 = &#123; extends:component, data()&#123; return&#123; text:555 &#125; &#125;, mounted()&#123; console.log(this.$parent.$options.name) &#125;&#125;new Vue(&#123; name:&apos;myTest&apos;, el:&apos;#root&apos;, components:&#123; comp:comp2 &#125;, data()&#123; return &#123; text:2333 &#125; &#125;, template:` &lt;div&gt; &lt;span&gt;&#123;&#123;text&#125;&#125;&lt;/span&gt; &lt;comp&gt;&lt;/comp&gt; &lt;/div&gt;`&#125;) 当然，也可以通过$parent来改变响应的值。但是尽量不要去这样做。父组件也是可以进行设置的： 12345678910111213141516const parent = new Vue(&#123; name:'parent'&#125;)const comp2 = &#123; parent:parent, extends:component, data()&#123; return&#123; text:555 &#125; &#125;, mounted()&#123; console.log(this.$parent.$options.name) &#125;&#125; 这样声明是没有用的，结果还将是parent为调用该组件的名称，这时候想要定义父组件必须在new一个Vue的时候声明才有效果。 接下来看一个多层调用的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import Vue from 'vue'const childComponents = &#123; template:` &lt;div&gt;child child &#123;&#123;value&#125;&#125;&lt;/div&gt; `, inject:['yeye','value'], mounted()&#123; console.log(this.yeye) &#125;&#125;const component = &#123; props:&#123; active:Boolean, propOne:&#123; require:true &#125; &#125;, data()&#123; return &#123; text:0, style:&#123; width:'200px', height:'200px', border:'1px black solid' &#125; &#125; &#125;, mounted()&#123; console.log('comp instance'); &#125;, components:&#123; childComponents &#125;, template:` &lt;div :style="style"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;child-components&gt;&lt;/child-components&gt; &lt;/div&gt; `&#125;new Vue(&#123; name:'myTest', el:'#root', components:&#123; comp:component &#125;, provide()&#123; return&#123; yeye:this, value:this.value &#125; &#125;, data()&#123; return &#123; text:2333, value:222222 &#125; &#125;, mounted()&#123; // console.log(this.$parent.$options.name) &#125;, template:` &lt;div&gt; &lt;comp&gt; &lt;span&gt;&#123;&#123;text&#125;&#125;&lt;/span&gt; &lt;/comp&gt; &lt;input type="text" v-model="value"/&gt; &lt;/div&gt;`&#125;) 但是是没有办法访问越级的组件的，这个时候就需要去做一些处理。 首先在”爷爷辈“的组件中，声明一个provide方法，这样才会在Vue对象初始化的过程中得到里面的值。 123456provide()&#123; return&#123; yeye:this, value:this.value &#125; &#125;, 然后在”孙子辈“里面再去利用inject调用： 123456789const childComponents = &#123; template:` &lt;div&gt;child child &#123;&#123;value&#125;&#125;&lt;/div&gt; `, inject:['yeye','value'], mounted()&#123; console.log(this.yeye) &#125;&#125; 但是这时候，如果在input中输入一个数的话，孙子中绑定的值是不会变化的，这是因为默认情况下provide是不提供Vue的react属性的，可以做下面的处理： 1234567891011provide()&#123; const data = &#123;&#125; Object.defineProperty(data,'value',&#123; get: ()=&gt; this.value, enumerable:true &#125;) return&#123; yeye:this, data &#125; &#125;, 也就是子组件在每次访问value这个属性的时候，实际上是在访问get方法，然后访问到value值的变化，这也就是Vue实现的一个原理，但是Vue官方文档中可能之后会被移除。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[computed和watch]]></title>
    <url>%2F2018%2F11%2F03%2F%E4%B8%80%E3%80%81computed%E7%9B%B8%E5%85%B3%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[一、computed相关的用法说明先看下面这行代码的效果： 123456789101112131415161718192021222324252627282930import Vue from 'vue'new Vue(&#123; el:'#root', template:` &lt;div&gt; &lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;getname()&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;number&#125;&#125;&lt;/div&gt; &lt;input type="text" v-model="number"/&gt; &lt;/div&gt; `, data:&#123; firstname:'Jone', lastname:'Lou', number:0 &#125;, computed:&#123; name()&#123; console.log('new name') return `$&#123;this.firstname&#125; $&#123;this.lastname&#125;` &#125; &#125;, methods:&#123; getname()&#123; console.log('new name invoke') return `$&#123;this.firstname&#125; $&#123;this.lastname&#125;` &#125; &#125;&#125;) ​ 这里在computed中声明了一个name()方法和getname()方法，在改变输入框的值时候，整个应用的值是会被重新渲染的，可以发现computed中的方法并没有被触发，但是getname()中的方法被触发了。这对性能的优化是很有效的。但是并不是改变的时候都不会触发。如果这个时候在template中加上： 12&lt;input type="text" v-model="firstname"/&gt; &lt;input type="text" v-model="lastname"/&gt; 并且在输入框中改变输入的值的时候，就会看见input中的值改变了computed中的方法被触发了。这是当它依赖的值被改变的时候它的计算属性会被调用。 当然，computed还可以做一些属性的设置： 1234567891011121314computed:&#123; name:&#123; get()&#123; console.log('new name'); return `$&#123;this.firstname&#125; $&#123;this.lastname&#125;` &#125;, set(name)&#123; const names = name.split(' ') this.firstname = names[0] this.lastname = names[1] console.log('hhh') &#125; &#125; &#125;, 这里可以对name设置get和set方法从而实现读取的相关操作。 二、watchwatch可以对一个变量的值的变化进行监听，并做一些响应的操作。这里我们对firstname及逆行一次监听： 12345watch:&#123; firstname(newname,oldname)&#123; this.fullname = newname+" "+this.lastname &#125;&#125;, 这里引入了一个新的变量叫fullname，并且在上面的div中对其进行渲染，可以看见，刚开始打开的时候并不能看见fullname的值，这是因为watch方法最初绑定的时候是不会被渲染的，只有被监听的值发生变化的时候才会被执行。当然我们也可以对其进行一些处理： 12345678watch:&#123; firstname:&#123; handler(newname,oldname)&#123; this.fullname = newname+" "+this.lastname &#125;, immediate:true &#125;&#125; 这样在初始化的时候就可以将数据渲染到页面上了。watch不适合用来做数据的显示，但适合见町名数据的变化并在后台做一些相关的处理。 当然，watch还有一个属性叫做deep这里做一个例子： 123456789101112//data obj:&#123; a:'123' &#125; //watchobj:&#123; handler(newname,oldname)&#123; console.log('obj.a changed') &#125;, immediate:true, //deep:true &#125; ​ 这里，如果在输入框中仅仅改变obj.a的值的时候，watch里面的方法并不会被触发，这是因为对象中的watch只会监听对象的变化，但是改变内部的属性是不起作用的。常用的办法就是加上deep:true。但这里也会有一个问题，每当对象中的属性发生变化的时候，不管和a这个属性有关还是无关，都会触发这个方法，这对性能是有影响的。一个好的处理办法就是将监听的obj换成字符串的’obj.a’。这时候就会只监听a属性。同时注意，在computed中不要对监听值进行修改，不然可能会导致无限次触发。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F10%2F31%2Fhello-world%2F</url>
    <content type="text"><![CDATA[js——Vuex相关用法 平时在一个vue组件中，里面的数据和方法只有在但当前的.vue组件中可以访问和使用，其他的组件是无法访问的。但是在实际的业务逻辑中，经常有跨组件数据的需求，因此，Vuex的设计就是为了用来统一管理组件状态的。它定义了一系列的规范来使用和操作数据，使组件应用更加高效。 Vuex的基本用法： 首先通过NPM安装Vuex： npm install –save vuex 在main.js中通过Vue.use()使用Vuex： store包含了应用的数据（状态）和操作过程。任何组件使用同一store的操作的数据时，只要store的数据发生变化，对应的组件也会立刻更新。 在任何组件内，可以直接通过$store.state.count 读取这个数据： 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div class="hello"&gt; &lt;p&gt;&#123;&#123;$store.state.count&#125;&#125;&lt;/p&gt; &lt;button @click="handleIncrement"&gt;+1&lt;/button&gt; &lt;button @click="handleDecrease"&gt;-1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'HelloWorld', data () &#123; return &#123; msg: 'Welcome to Your Vue.js App' &#125; &#125;, methods:&#123; handleIncrement () &#123; this.$store.commit('increment'); &#125;, handleDecrease () &#123; this.$store.commit('decrease'); &#125; &#125;&#125;&lt;/script&gt; 当然，以上$store.state.count亦可以换成count，然后后面加上： 12345computed:&#123; count()&#123; return this.$store.state.count; &#125; &#125; 在组件内，来自store的数据只能读取，不能手动改变，改变store数据的唯一途径就是显式的提交mutatations。他是Vuex的第二个选项，用来直接修改state里的数据。 Vuex还有其他的三个选项可以使用：getters、actions、modules。 123456789101112131415161718getters:&#123; getNum:state =&gt; &#123; return state.list.filter(item =&gt; item &lt; 10); &#125;, listCount:(state,getters) =&gt; &#123; return getters.getNum.length; &#125; &#125;//.vue文件中computed:&#123; count()&#123; return this.$store.state.count; &#125;, listCount () &#123; return this.$store.getters.listCount; &#125; &#125; 这里，getter也可以依赖于其他的getter，把getter作为第二个参数。如上例中的listCount。 注意的是，mutation里面不应该出现异步操作的数据，因此有了actions，他和mutation很像，但是提交的是mutation，并且可以异步操作业务逻辑。 action在组件中通过$store.dispatch触发，例如使用action加一： 123456789101112131415//main.jsactions:&#123; increment (context) &#123; context.commit('increment') &#125; &#125; //.vue methods:&#123; handleIncrement () &#123; this.$store.dispatch('increment'); &#125;, handleDecrease () &#123; this.$store.commit('decrease'); &#125; &#125;, 下面是处理异步操作的代码： 12345678910111213141516171819202122//main.jsactions:&#123; increment (context) &#123; return new Promise(resolve =&gt;&#123; setTimeout(()=&gt;&#123; context.commit('increment'); resolve(); &#125;,1000) &#125;) &#125; &#125; //.vue methods:&#123; handleIncrement () &#123; this.$store.dispatch('increment').then(()=&gt;&#123; console.log(this.$store.state.count) &#125;); &#125;, handleDecrease () &#123; this.$store.commit('decrease'); &#125; &#125;, mutation和actions看起来很相似，但一般涉及改变数据的时候用Vue，存在业务逻辑的时候用actions。 最后一个是module，主要是用来将store分割到不同的模块，微地就是让main.js中的store看起来更友好。 12345678910111213141516171819202122232425262728var moduleA = &#123; state:&#123; count:0 &#125;, mutations:&#123; hello()&#123; console.log('hello') &#125; &#125;&#125;var moduleB = &#123; state:&#123; count:1 &#125;, mutations:&#123; get(state)&#123; console.log('state=' + state.count) &#125; &#125;&#125;const store = new Vuex.Store(&#123; modules:&#123; a:moduleA, b:moduleB &#125;&#125;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[标签]]></title>
    <url>%2F2017%2F02%2F22%2Fweb%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[web缓存机制在chrome的开发者工具中，在network /Size一列中可以看见一些请求，如果在这列中明确标明大小KB,B，说明这是一个网络请求，否则一般都会明确标明：from memory cache,from disk cache和from ServiceWorker. 优先级依次是： Service Worker Memory Cache Disk Cache 网络请求 1、Memory Cache ​ 它是内存中的缓存，和硬盘中的缓存相对。几乎所有的网络请求资源都会被浏览器加入到memory cache中去，但由于数量大所以是个短期的存储过程。当浏览的TAB页关闭的时候就失效了。或者一个页面占用的缓存过多的时候会导致前面的TAB缓存还没关闭就失效了。 ​ （1）preloader ​ 一般浏览器在打开网站的时候都是请求js/css，之后解析执行，然后再次解析下一个请求这样的穿行操作，那么现在，能不能一边解析js/css，一边请求下一个资源，这就是preloader所干的事。memory cache机制保证了一个页面中若有两个相同的请求的时候，（比如有两个相同href的)都实际上只进行一次请求。在匹配缓存的时候，除了会对他们的URL进行匹配。也会对他们的类型、CORS中的域名规则进行校对。比如在script中缓存的资源不能用在image图片类型的请求中，即使他们的src相同。 ​ （2）从memory cache中获取缓存内容的时候，浏览器自动忽略max-age=0,no-cache这些头部配置。因为memory cache只是短时间使用，大部分生命周期只有一次。max-size意思也就是“不要在下次浏览时使用”，和memory cache不冲突。如果真的不想让一个资源进入缓存，即使一次都不想，就可以使用no-store。这样memory cache就不会存储它了 2、disk cache ​ 也叫HTTP cache，是存储在硬盘上的缓存，是持久存储的，实际存在于文件系统当中。允许相同资源跨会话，甚至站点进行使用。他会严格根据HTTP头部信息进行判断哪些资源缓存，哪些可用，哪些过期了需要重新发送请求。命中之后浏览器会从硬盘中去读取资源，虽然过程会比内存中读取慢但是比网络请求快很多。一般大部分的缓存都是来自disk cache。 3.Service Worker ​ 以上的缓存机制和读取，缓存以及失效的行为都是通过浏览器判断进行的，只能通过设置响应的头部告诉浏览器应该做什么。而Service Worker就是一种更直接的方式，这个缓存是永久的，即使关闭TAB或者是关闭浏览器都不能将其删除。只有以下两种情况才会将其删除：手动调用API：cache.delete(resource)或者容量溢出。会被浏览器清除。如果Service Worker没有命中，就会调用fetch()方法继续获取资源。虽然这个时候没有命中Service Worker缓存，用了网络请求，但是在Chrome中依然会被标记为from Service Worker。 4.请求网络 如果前面的三个缓存都没有命中，那么就通过网络请求的方式获取。但是在获取完成之后，需要处理如何将这个资源放在缓存中去的问题： 根据Service Worker中的handle决定是否存入Cache Storage(额外的缓存位置)。 根据HTTP头部的相关字段决定是否存入disk cache memory cache 保存一份资源 的引用 ​ ​]]></content>
      <categories>
        <category>web基础知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[webpack]]></title>
    <url>%2F2017%2F02%2F22%2F%E5%89%8D%E7%AB%AF11_2%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94webpack%2F</url>
    <content type="text"><![CDATA[前端11_2笔记——webpack 安装webpack配置 首先在新建的项目中npm init新建一个npm项目，然后安装webpack相关的组件 1npm i webpack vue vue-loader 同时还需要安装： 1npm i css-loader vue-template-compiler 新建一个app.vue并写入一些组件，新建一个webpack.config.js进行一些设置。 新建一个index.js进行入口文件的设置 1234567891011import Vue from 'vue'import App from './app.vue'import './styles/test.css'import './styles/test-stylus.styl'const root = document.createElement('div');document.body.appendChild(root);new Vue(&#123; render:(h) =&gt; h(App)&#125;).$mount(root) webpack只支持js文件并且只支持ES5的语法，所以需要进行一些处理： 12345678module:&#123; rules:[ &#123; test:/\.vue$/, loader:'vue-loader' &#125; ] &#125;, 并且vue-loader在15.*之后的版本都是 vue-loader的使用都是需要伴生 VueLoaderPlugin的，具体内容可详见https://vue-loader.vuejs.org/guide/#vue-cli 所以进行以以下处理： 123456789101112131415161718// webpack.config.jsconst VueLoaderPlugin = require('vue-loader/lib/plugin')module.exports = &#123; module: &#123; rules: [ // ... other rules &#123; test: /\.vue$/, loader: 'vue-loader' &#125; ] &#125;, plugins: [ // make sure to include the plugin! new VueLoaderPlugin() ]&#125; 之后运行npm run dev就能够看见新建了一个dist的文件，并且底下有一个bundle.js文件，webpack所作的工作就是把不同的的静态资源文件打包成一个.js文件，然后在html中去引入这个文件实现。因为在http中将零散的文件打包成一个减少http请求的次数。 1.处理.vue文件 在webpack.config.js文件中，利用module来设置rules： 1234&#123; test:/\.vue$/, loader:'vue-loader'&#125; 2.处理CSS文件 利用css-loader来处理CSS文件，但是在实际运用的过程当中会有不同的处理方式，所以这时候需要换一种写法： 12 最终，CSS代码会写入到js文件中去，并且最终会引入到html当中去。 3.图片的处理方式 这里loader使用一个对象去写，因为实际上一个对象是可以进行配置的，利用options可以对其进行配置： 这里，url-loader可以将图片转换为Base-64代码直接插入到js中去，不用生成新的图片，这对于我们几KB的文件是很有用的，就不用生成http请求。url-loader实际上封装了file-loader，其就是将图片进行读取并进行一些简单的操作之后重新存储。limit设置了转换图片的大小。 12345loader:'url-loader',options:&#123; limit:1024, name:'[name]-aaa.[ext]'&#125; 配置之后需要安装相应的模块： 1npm i style-loader url-loader file-loader 4.CSS CSS预处理器就是用模块化的思想去写CSS代码。比如利用.styl 12345678&#123; test:/\.styl/, use:[ 'style-loader', 'css-loader', 'stylus-loader' ]&#125; 并安装stylus和stylus-loader 配置webpack-dev-server首先安装这个包 1npm i webpack-dev-server 在package.json中的scripts加入”dev”:”webpack-dev-server –config webpack.config.js” 然后在webpack.config.js中全局加入target:’web’，同时需要判断正式环境和开发环境： 安装cross-env可以保证我们在不同的平台执行同一个脚本,在package.json中的build下加入 12"build": "cross-env NODE_ENV=production webpack --config webpack.config.js","dev": "cross-env NODE_ENV=development webpack-dev-server --config webpack.config.js" 当启动脚本的时候设置的环境变量全部都是设置在process.env里面的，可以在process.env中设置多个变量名并读取到这些变量。 然后设置当环境为production的时候，进行对server的配置： 1234567891011if(isDev)&#123; config.devServer = &#123; port:'8000', //设置成0.0.0.0好处是可以通过内网的IP进行访问，而localhost就不行 host:'0.0.0.0', //当编译有错误的时候，可以将我们的错误显示到我们的网页上 overlay:&#123; errors:true &#125; &#125;&#125; 现在需要一个html页面来显示我们的内容： 首先安装一个插件： 1npm i html-webpack-plugin 之后在最前面引入这个插件： 1const HTMLPlugin = require('html-webpack-plugin') 并进行调用： 123456789101112plugins: [ // make sure to include the plugin! new VueLoaderPlugin(), new HTMLPlugin(), //这个是用来给wewbpack在编译的时候和js代码运行时判断环境 //提供相关的框架去区分打包 new webpack.DefinePlugin(&#123; 'process.env':&#123; NODE_ENV:isDev ? '"development"' : '"production"' &#125; &#125;) ] 热加载在config.devServer中设置 1hot:true, 然后设置下面的两个选项： 1234config.plugins.push( new webpack.HotModuleReplacementPlugin(), new webpack.NoEmitOnErrorsPlugin() ) 并在前面引入webpack： 1const webpack = require('webpack') 并且设置devtool 1234//这是帮助我们调试代码 //利用sourcemap进行代码的映射，在浏览器中打开的还是我们正常写的代码。 //提高效率和准确性 config.devtool = '#cheap-module-eval-source-map' 最终，在webpack.config.js中的代码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384‘const path = require('path')const VueLoaderPlugin = require('vue-loader/lib/plugin')const HTMLPlugin = require('html-webpack-plugin')const webpack = require('webpack')const isDev = process.env.NODE_ENV === 'development'const config = &#123; target:'web', entry:path.join(__dirname,'src/index.js'), output:&#123; filename:'bundle.js', path:path.join(__dirname,'dist') &#125;, module:&#123; rules:[ &#123; test:/\.vue$/, loader:'vue-loader' &#125;,&#123; test:/\.css$/, use:[ 'style-loader', 'css-loader' ] &#125;,&#123; test:/\.(gif|jpg|jpeg|png|svg)$/, use:[ &#123; loader:'url-loader', options:&#123; limit:1024, name:'[name]-aaa.[ext]' &#125; &#125; ] &#125;,&#123; test:/\.styl/, use:[ 'style-loader', 'css-loader', 'stylus-loader' ] &#125; ] &#125;, plugins: [ // make sure to include the plugin! new VueLoaderPlugin(), new HTMLPlugin(), //这个是用来给wewbpack在编译的时候和js代码运行时判断环境 //提供相关的框架去区分打包 new webpack.DefinePlugin(&#123; 'process.env':&#123; NODE_ENV:isDev ? '"development"' : '"production"' &#125; &#125;) ]&#125;if(isDev)&#123; //这是帮助我们调试代码 //利用sourcemap进行代码的映射，在浏览器中打开的还是我们正常写的代码。 //提高效率和准确性 config.devtool = '#cheap-module-eval-source-map' config.devServer = &#123; port:'8000', //设置成0.0.0.0好处是可以通过内网的IP进行访问，而localhost就不行 host:'0.0.0.0', //当编译有错误的时候，可以将我们的错误显示到我们的网页上 overlay:&#123; errors:true &#125;, //每次编译完成后都会打开浏览器 //open:true //hot不会重新加载页面而是直接渲染组件。 hot:true, &#125; config.plugins.push( new webpack.HotModuleReplacementPlugin(), new webpack.NoEmitOnErrorsPlugin() )&#125;module.exports = config; CSS分离： 之前的CSS代码在打包之后都是在同一个.js文件中，并且里面内容很多不容易找到，这时候需要利用相关的插件对CSS进行分离。 首先先npm i extract-text-webpack-plugin 然后在webpack.config.js文件中添加const ExtractPlugin = require(‘extract-text-webpack-plugin’)，这个就是将我们的非js代码单独打包成一个文件，因为这个文件有可能会作为缓存和利用js将一些样式写入页面中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130const path = require(&apos;path&apos;)const VueLoaderPlugin = require(&apos;vue-loader/lib/plugin&apos;)const HTMLPlugin = require(&apos;html-webpack-plugin&apos;)const webpack = require(&apos;webpack&apos;)const ExtractPlugin = require(&apos;extract-text-webpack-plugin&apos;)const isDev = process.env.NODE_ENV === &apos;development&apos;const config = &#123; target:&apos;web&apos;, entry:path.join(__dirname,&apos;src/index.js&apos;), output:&#123; filename:&apos;bundle.js&apos;, path:path.join(__dirname,&apos;dist&apos;) &#125;, module:&#123; rules:[ &#123; test:/\.vue$/, loader:&apos;vue-loader&apos; &#125;, &#123; test:/\.jsx$/, loader:&apos;babel-loader&apos; &#125;, &#123; test:/\.(gif|jpg|jpeg|png|svg)$/, use:[ &#123; loader:&apos;url-loader&apos;, options:&#123; limit:1024, name:&apos;[name]-aaa.[ext]&apos; &#125; &#125; ] &#125; ] &#125;, plugins: [ // make sure to include the plugin! new VueLoaderPlugin(), new HTMLPlugin(), //这个是用来给wewbpack在编译的时候和js代码运行时判断环境 //提供相关的框架去区分打包 new webpack.DefinePlugin(&#123; &apos;process.env&apos;:&#123; NODE_ENV:isDev ? &apos;&quot;development&quot;&apos; : &apos;&quot;production&quot;&apos; &#125; &#125;) ]&#125;if(isDev)&#123; config.module.rules.push(&#123; test:/\.css$/, use:[ &apos;style-loader&apos;, &apos;css-loader&apos; ] &#125;,&#123; test:/\.styl/, use:[ &apos;style-loader&apos;, &apos;css-loader&apos;, &#123; loader:&apos;postcss-loader&apos;, options:&#123; sourceMap:true, &#125; &#125;, &apos;stylus-loader&apos; ] &#125;) //这是帮助我们调试代码 //利用sourcemap进行代码的映射，在浏览器中打开的还是我们正常写的代码。 //提高效率和准确性 config.devtool = &apos;#cheap-module-eval-source-map&apos; config.devServer = &#123; port:&apos;8000&apos;, //设置成0.0.0.0好处是可以通过内网的IP进行访问，而localhost就不行 host:&apos;0.0.0.0&apos;, //当编译有错误的时候，可以将我们的错误显示到我们的网页上 overlay:&#123; errors:true &#125;, //每次编译完成后都会打开浏览器 //open:true //hot不会重新加载页面而是直接渲染组件。 hot:true, &#125; config.plugins.push( new webpack.HotModuleReplacementPlugin(), new webpack.NoEmitOnErrorsPlugin() )&#125; else&#123; config.output.filename = &apos;[name].[chunkhash:8].js&apos; config.module.rules.push(&#123; test:/\.styl/, use:ExtractPlugin.extract(&#123; fallback:&apos;style-loader&apos;, use:[ &apos;css-loader&apos;, &#123; loader:&apos;postcss-loader&apos;, options:&#123; sourceMap:true, &#125; &#125;, &apos;stylus-loader&apos; ] &#125;) &#125;,&#123; test:/\.css$/, use:ExtractPlugin.extract(&#123; fallback:&apos;style-loader&apos;, use:[ &#123; use:[ &apos;css-loader&apos; ] &#125; ] &#125;) &#125;) config.plugins.push( new ExtractPlugin(&apos;styles.[contentHash:8]&apos;) )&#125;module.exports = config;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
</search>
