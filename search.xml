<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js事件循环]]></title>
    <url>%2F2018%2F12%2F08%2Fjs%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[再谈web缓存]]></title>
    <url>%2F2018%2F12%2F08%2F%E5%86%8D%E8%B0%88web%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[缓存类型​ web缓存主要分为服务端侧的缓存（如Nginx和Apache）和客户端的缓存（浏览器）。 ​ 这里我们主要讨论的是浏览器缓存，其主要分为强缓存和协议缓存两个类： 强缓存：浏览器在加载资源的时候，会首先根据http header来判断这个请求是否命中自己的缓存，如果可以命中，就直接从自己的缓存中读取这个资源，而不会再向服务器发送请求。 协议缓存：如果强缓存没有命中的时候，浏览器就会发送一个请求到服务器上，此时服务器就会听过判断http header来判断这个请求是否命中协议缓存。如果命中，浏览器就会将这个请求返回（返回码304），这里不会返回请求的资源，而是告诉浏览器直接从缓存中去加载这个资源。若没有命中，就会将资源返回，冰球更新本地缓存，此时的状态码是200 这里需要强调的是，强缓存和协议缓存的最大区别就是是否向服务器发送了请求。强缓存是不会发请求到服务器的，直接在浏览器中进行处理，但是协议缓存会向服务器中发送请求。 缓存的设置HTTP meta标签设置缓存&lt;META HTTP-EQUIV=&quot;Pragma&quot; CONTENT=&quot;no-cache&quot;&gt; ​ 通过meta标签来设置缓存，告诉浏览器只能通过发送请求的方式请求资源，不缓存当前页面。但是这种方式的缺点在于浏览器的兼容性不强，且由于代理服务器不能解析HTML代码，所以这段代码不能在代理服务器上运行。 HTTP头部信息的缓存设置Expires​ Expires是一种强缓存，是HTTP1.0中提出的一种缓存标准，由服务器返回一个绝对时间，用GMT字符串的格式返回。如：Expires:Thu, 31 Dec 2016 23:55:55 GMT，读取缓存的条件是：服务器的缓存过期时间 &lt; 客户端的当前时间。 ​ 很明显，这种方式有一个明显的缺陷就是如果服务器的当前时间和客户端的当前时间相差较大，比如牵扯到跨时区等问题，这种方式明显是不可取的，采用的另一种方式就是HTTP1.1标准中的Cache-Control:max-age=?来代替 Cache-Control​ 使用Cache-Control描述一个相对时间，在进行缓存处理的时候，都是采用客户端的时间进行判断。因此这个机制相较于Expires更加准确有效。 ​ Cache-Control可取的值有下面几种，含义如下： Public指示响应可被任何缓存区缓存。 Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当前用户的部分响应消息，此响应消息对于其他用户的请求无效。 no-cache指示请求或响应消息不能缓存，该选项并不是说可以设置”不缓存“，而是需要和服务器确认 no-store在请求消息中发送将使得请求和响应消息都不使用缓存，完全不存下來。 max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。上次缓存时间（客户端的）+max-age（64200s）&lt;客户端当前时间 min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。 max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。 Last-Modified和If-Modified-Since​ Last-Modified表示的是这个资源的最后修改时间，If-Modified-Since代表的是资源过期后（强缓存失效），如果该资源具有If-Modified-Since这个特性，那么在向web服务器发送请求的时候就会携带If-Modified-Since表示请求时间。web服务器在收到请求之后发现If-Modified-Since就会将请求资源的时间和资源修改的最后时间进行对比。如果这段时间内资源发生了修改，就会将这个资源整体全部返回，HTTP状态码返回的是200，如果这段时间没有发生修改，就会返回HTTP 304，告诉浏览器继续使用缓存。 ​ 同时这种方式也明显有个缺点，就是某些文件会定期生成，有时候虽然文件的内容并没有发生改变，但是Last-Modified却改变了，这样就会导致文件的缓存没办法使用，从而出现服务器中没有获取文件的准确修改时间等无法使用缓存的现象。 ​ 并且，这种方式的Last-Modified标注修改只能精确到秒级，如果有一个文件在一秒之内被修改了很多次的话，就会导致不能准确修改文件的修改时间问题，无法即使的修改文件。 Etag和If-None-Match​ HTTP1.1中的Etag/If-None-Match解决了上面Last-Modified的一些问题。同时他们也需要配合Cache-Control使用。其机制和Cache-Control相似，不过，Etag是服务器自动生成或由开发者生成的资源在服务器中的唯一标识符，可以更加准确的控制缓存。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。 以上过程总结成流程图如下所示： 1）当浏览器第一次请求的时候： 2）浏览器再次请求的时候： 同时，以上提到的各种缓存机制还和用户的行为有关，具体如下所示：]]></content>
      <categories>
        <category>Web性能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浅谈web安全]]></title>
    <url>%2F2018%2F12%2F04%2F%E6%B5%85%E8%B0%88web%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[一、同源策略同源策略的简介​ 同源策略是web浏览器最基本也是最核心的安全机制，所谓同源策略，就是指浏览器限制了来自不同源的“document”或者脚本，对当前”document“的读取或是修改。这个策略对于web安全是很重要的，可以想象下，如果一个test.com可以在test2.com没有加载的情况下，随意读取或是修改其内容，会发生极大的安全隐患。因此，这一策略对于web安全而言是及其重要的。 ​ 对javascript而言，同源的判定通常由以下几种情况（以http://www.baidu.com为例）： URL RESULT REASON http://www.baidu.com/index.html 可以请求 同源下的不同界面 http://www.baidu.com/aa.html 可以请求 同源下的不同界面 http://www.baidu.com:8081/ 不能请求 端口号不同，不同源 http://map.baidu.com/ 不能请求 域名不同，不同源 https://www.baidu.com 不能请求 协议不同，不同源 ​ 同样这里需要说明的是，对于当前页面而言，当前存放的脚本文件的域无关紧要，重要的在于加载这个JavaScript脚本的页面所在的域是在哪儿。比如如果我们会通常在我们本地域localhost中利用script标签加载了一个jquery文件： 1&lt;script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"&gt; ​ 这个时候虽然我们加载了另一个源的js文件，但是这个js文件是运行在localhost这样的一个域下面的，对于在本地域中的页面来说，实际上jquery.min.js则会个文件就是localhost的而不是我们请求的这个网站的。 同源策略及跨域问题​ 并且我们可以发现，其实在编写html代码的时候，这些标签我们通常都会做一些跨域的请求： 123&lt;script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"&gt;&lt;img src="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=3146759643,3585562365&amp;fm=58"/&gt;&lt;link href="img/divcss5.css" rel="stylesheet" type="text/css" /&gt; ​ 这些常用的标签都是被允许进行跨域请求请求加载资源的，不会受到同源策略的限制。并且通过src实际上就是发送了一次GET请求。 ​ 通常我们所说的同源策略主要体现在以下的几个方面： DOM同源策略：即禁止对不同源页面的DOM进行操作。 XMLHttpRequest同源策略：禁止通过XMLHttpRequest向不同源的服务器发送请求。 其他的同源策略：cookie、浏览器的第三方插件等 ​ 这里，最需要关注的主要是XMLHttpRequest同源策略。因为很多时候我们在开发web应用的时候，难免会发出不同源的请求。我们通常就将这种请求称为跨域问题。如果不做任何跨域处理，我们就会发现在浏览器的控制台会有以下的报错： ​ 这就是由于同源策略拒绝了我们的请求所导致的。因此，在前端ajax，包括一些使用了ajax原理的相关插件，在这里都会存在跨域的问题需要注意。 跨域问题的改进和安全性问题​ 由于这里我们只讨论与web安全有关的问题，故这里不针对跨域问题展开来讲，只是由于互联网目前随着相关技术的发展，有时又不能不进行相关的跨域请求。W3C目前对于XMLHttpRequest制定的标准是通过HTTP头部来确认是否允许跨域。但是，问题就在于这个方案的提出是建立在我们认为JavaScript不能对HTTP头部进行更改而形成的，如果这个基础不成立的话，这种方案实际上也是不安全的。 ​ 当然，同源策略也并不是完全可靠的，也会存在部分跨域漏洞导致同源策略被绕过。比如在IE8中存在一种CSS跨域漏洞。由于之前提到，一些例如&lt;script&gt;之类的标签可以进行跨域请求加载资源，而这里就会存在漏洞使其能够读取到页面信息，从而造成内容的泄露。这就是由于绕过同源策略造成的。 浏览器沙箱浏览器多进程安全机制​ 现代浏览器大多采用多线程的架构，这样做一方面是为了将浏览器的各个不同的功能分开方便管理，一方面实际上也是为了安全性考虑。将浏览器中的各个功能分开，即使有一个进程出现崩溃或者受到攻击，也不会影响到其他进程的正常运行，相较于单线程中一个线程崩溃导致 浏览器整个崩溃而言，这种机制提供了很好的用户体验，并且在web安全上有了很大的提升。 ​ 一般来讲，浏览器的每一个标签tab都是一个进程，同时这些进程可能还包含下面的一些进程： Browser进程：作为浏览器的主进程，，负责主要的协调和主控，一般只有一个。 GPU进程：用于3D渲染。 浏览器渲染进程：每个tab都会有这样的进程，负责页面DOM树渲染，脚本的执行，以及时间的处理等。 第三方插件：使用时才会调用这个插件 Sandbox技术的应用​ 在谷歌浏览器中，渲染引擎有Sandbox隔离，代码在和浏览器内核进程通信、操作系统通信的时候，都会通过IPC channel进行一些安全检查。Sandbox也被称作为沙箱。这种技术和我们一般常见的主动防御技术原理截然不同，主动防御机制一般是发现程序有可疑行为就会采取机制进行拦截处理。但是沙箱机制是通常在发现一个程序有可疑的行为就会让其在一个隔离的环境中运行，确认其是有害程序后会就行相关操作。其具体的流程归结为： ​ 让可以的程序先在隔离的沙箱中运行，沙箱负责监督并记录这个程序的每一次运行，当程序一旦暴露出其有害性的时候，沙箱就会立即回滚：将恶意程序的痕迹抹去并恢复系统到正常的状态。 ​ 同时。沙箱技术也会限制对资源的访问。在Chrome浏览器中，渲染引擎就是由Sandbox隔离的，使得网页的渲染相关的操作在一个独立的Render进程中执行，而这个引擎明显是受到限制的，会先知道这个进程对于一些数据信息的读取和资源的访问因此这种机制是一个相对比较安全的机制。 ​ 当然也可以选择跨过这种安全机制，只是需要调用相关的API接口来实现，但是为了保证系统的安全性，系统也会最初相应的严格安全检查机制来保证程序的可行度。 现代浏览器的问题​ 虽然目前多谢进程框架和Sandbox技术可以有效地保证web应用的相对安全性，但是目前在浏览器中出现的一些第三方插件，由于不受上述安全机制的管辖，并且目前而言也没有一个具体的标准来约束这些第三方插件的运行，所以目前而言，浏览器易受到第三方插件的漏洞攻击。 恶意网站的拦截机制​]]></content>
  </entry>
  <entry>
    <title><![CDATA[设计模式之策略模式]]></title>
    <url>%2F2018%2F11%2F26%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、策略模式的定义和初步使用1.引入​ 策略模式的定义是：“定义一系列的算法，把他们封装起来，并实现可以相互替换”。也就是说我们实现一个功能可能有多种算法，我们一般会根据不同的场景去选择不同的算法。这个定义说的并不是很清楚，我们可以根据下面的例子来说明这个模式。 ​ 比如我们现在要实现不同员工根据他们平时业绩表现来决定他们的薪水情况，常规的情况下我们会写出下面的算法： 123456789101112function calculate(level,salery)&#123; if(level == 'S')&#123; salery = salery * 4; &#125;else if(level == 'A')&#123; salery = salery * 2; &#125;else&#123; salery = salery; &#125; return salery&#125;console.log(calculate('S',1000))console.log(calculate('A',500)) ​ 上面的算法执行的结果是没有问题的，但是仔细分析我们可以发现上面的代码实际上并不符合绝大部分用户要求，原因有如下几点： 上述代码的if-else语句过多，导致逻辑的覆盖面需要很广泛，否则不能将所有的情况覆盖到 上面的代码中，如果之后有更多的等级需要覆盖，或者某个等级的策略有变化，我们需要深入到calculate这个函数中去，这丫昂违背了开放-封闭的原则。 这个算法复用性不好，如果其他地方有需要用并稍稍有点修改，就需要去复制粘贴一大段代码，重复代码较多。 ​ 基于以上的分析，我们需要对上述代码进行修正，运用策略模式使代码更加规范。 2.使用策略模式重构代码​ 首先我们需要明确策略模式的原则，就是定义一系列的算法，并实现他们的封装，并且让算法的使用和算法的实现分离。 12345678910111213141516171819202122232425262728293031323334353637/* 定义几个策略*/var levelS = function()&#123;&#125;levelS.prototype.calculate = function(salery)&#123; return salery * 4&#125;var levelA = function()&#123;&#125;levelA.prototype.calculate = function(salery)&#123; return salery * 2&#125;var levelB = function()&#123;&#125;levelB.prototype.calculate = function(salery)&#123; return salery * 0.5&#125;/* 实现奖金类*/var Salery = function()&#123; this.salery = null; this.strategy = null;&#125;Salery.prototype.setSalery = function(salery)&#123; this.salery = salery&#125;Salery.prototype.setStrategy = function(strategy)&#123; this.strategy = strategy&#125;Salery.prototype.getSalery = function()&#123; return this.strategy.calculate(this.salery)&#125;//进行测试var me = new Salery();me.setSalery(50000);me.setStrategy(new levelS())console.log(me.getSalery()) ​ 这段代码中将不同策略的定义和策略的实现放在了两个不同的地方分来执行。当我们在实现类中执行这个方法的时候，实际上是将需要的策略类型实例化并传给setStrategy这样的函数，从而实现了对实现类策略的设置。当我们需要去执行这个策略的时候，实现类就会去调取之前我们定义的策略类，委托给他去执行。下一次如果是一个不一样的策略的时候，只需要在setStrategy里面传入不同的参数即可。这样就实现了我们之前那所说的算法之间可以相互替换。策略类和实现类分离。当然，这里我们主要使用的是面向对象的写法来实现这个功能，接下来尝试用JavaScript的特性来实现这个功能。 二、JavaScript实现策略模式​ 在上面的例子里面，我们是把不同的策略按照不同的对象来实现的。在JavaScript里面，我们还可以运用JavaScript的特点来实现这个功能。在一个类中将整个策略列举出来，用键代表策略的名，值就是策略的具体内容： 123456789101112131415161718var strategies = &#123; "S":function(salery)&#123; return salery * 4 &#125;, "A":function(salery)&#123; return salery * 2 &#125;, "B":function(salery)&#123; return salery * 0.5 &#125;&#125;var calculate = function(level,salery)&#123; return strategies[level](salery)&#125;console.log(calculate('S',10000))console.log(calculate('A',10000)) ​ 很明显，利用这种方式来实现明显从代码简洁度上要好很多，直接将策略类型在strategies里面罗列出来，并在calculate里面通过键找到对应的策略并执行相应的方法。于是整个策略执行完成。 三、具体应用与实例​ （待更新）]]></content>
      <categories>
        <category>javascript设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js原型和原型链]]></title>
    <url>%2F2018%2F11%2F26%2Fjs%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[对原型的引入​ 在每一个JavaScript对象里都会内置一个特殊的属性[[Prototype]]，这个属性在几乎所有对象创建的时候都会被赋予一个非空值。假设我们开始创建了这样的一个对象： 1234var obj = &#123; name:'liming'&#125;console.log(obj.name) ​ 但是如果在obj中没有name这样的一个属性，很明显我们就无法访问这个了。如果还有需要，就要引入原型链。比如下面的这个例子： 12345var obj = &#123; name:'liming'&#125;var obj1 = Object.create(obj)console.log(obj1.name) ​ 在这个例子里面虽然obj1并没有设置name这个属性，但是通过创建的时候通过Object.create这个方法我们将他的原型设置成了obj，从而之后js在寻找的时候，发现obj1没有这个属性，就会去他的原型链上查找。直到把原型链遍历完为止。 prototype和constructor一个例子​ 刚刚提到，在我们建立一个对象的时候，会默认生成他的一个原型prototype，当我们实例化对象的时候，这个实例化的对象中有一个属性__proto__会指向原型prototype，原型中有一个属性叫做constructor ，他会指向创建这个对象的函数。比如我们来看下面的这个例子： 12345678910111213function Person() &#123; name = 'Person'; this.height = '160cm';&#125;//在其原型对象中添加age属性Person.prototype.age = '18';console.log(Person.prototype.name)console.log(Person.prototype.constructor)//Person的实例p1var p1 = new Person();console.log(p1.age)console.log(p1.name)console.log(p1.__proto__) ​ 我们用一张图来表示上述过程： 分析​ 首先我们利用function创建了一个Person类，这个类中name是直接赋值得到，而height用了this声明。这个类创建好后，会为我们自动创建一个原型Person.prototype，这个原型中只有一个属性constructor，它是指向Person类的构造函数，所以如果我们输出Person.prototype.constructor，会输出[Function: Person]。如果我们试图去访问Person.prototype.height，将会输出undefined。之后我们又在他的属性里面添加了一个age属性。 ​ 之后我们创建了一个实例化的对象p1，创建实例化对象的时候系统会自动为我们生成一个属性__proto___，指向new这个实例的构造函数的原型对象，这里就是Person.prototype。当我们访问name的时候，由于name虽然是Person的一个属性，但是并没有用this声明，所以p1并不拥有这样的一个属性，即使到他的原型中也不存在，所以就会是undefined。当访问height搭的时候，由于在实例化对象创建的时候就有，所以能够正常输出。访问age的时候，虽然p1中并没有这样的一个属性，但是js会向上寻找他的原型Person.prototype，这里有这样的一个属性age，就会将其输出。 过程总结​ 所以对这几个重要的概念进行梳理： prototype：构造函数中的属性，指向该构造函数的原型对象。 constructor：原型对象中的属性，指向该原型对象的构造函数 __proto__：实例中的属性，指向new这个实例的构造函数的原型对象 在我们var p1 = new Person()的时候，实际发生了下面的过程： 1.var p1 = new Object(); //此时p1.proto = Object Prototype 2.p1.__proto__ = Person.prototype; 3.Person.call(p1);//使用新对象p1调用函数Person，将this作用域给p1 原型链​ 如果在上述例子中，我们将代码做下面的处理，会发现一些不一样的结果： 1234567891011121314function Person() &#123; name = 'Person'; this.height = '160cm';&#125;Person.prototype = &#123; age:18&#125;console.log(Person.prototype.name)console.log(Person.prototype.constructor)//Person的实例p1var p1 = new Person();console.log(p1.age)console.log(p1.name)console.log(p1.__proto__) ​ 这里，我们将Person.prototype.age = ‘18’改为用对象的形式单独写出，但会发现，输出结果中Person.prototype.constructor变成了[Function: Object]，说明现在，Person.prototype.constructor指向已经不再是Person了。这是由于如果我们将一个Person.prototype单独附一个对象，实际上他的constructor已经指向了Object的构造函数，他还多了一个__proto__指向了Object.prototype。整个原型链如下所示： ​ 但如果这个时候，我们有需求将construct指向Person，那么这时候就需要用到下面的这种定义方式： 123456Object.defineProperty(Person.prototype,"constructor",&#123; enumerable:false, writable:true, configurable:true, value:Person&#125;) 类的继承​ 实现类的继承有以下几种方式，但是有的会有些意想不到的缺陷： 组合继承​ 通过结合原型链和构造函数，我们可以实现组合继承。通过构造函数实现每个类的特有属性，通过原型链是他们拥有共同的方法，实现方法的复用。 123456789101112131415function Person(name)&#123; this.name = name; this.age = 18&#125;Person.prototype.sayName = function()&#123; return this.name;&#125;function Student(name,num)&#123; Person.call(this,name) this.num = num;&#125;Student.prototype = new Person();console.log(Student.prototype.constructor)Student.prototype.constructor = Personvar stu1 = new Student('liming',12) ​ 这种方式有下面几个缺点： ​ 1.会导致两次调用超类的构造函数，一次在Person.call，另一次在 Student.prototype = new Person()。 ​ 2.两次调用构造函数会导致Person的原型上有name和age，在stu实例上也有name和age。 原型式继承12345678910111213141516function Person(name)&#123; this.name = name; this.age = 18&#125;Person.prototype.sayName = function()&#123; return this.name;&#125; function Student(name,num)&#123; Person.call(this,name) this.num = num&#125;Student.prototype = Object.create(Person.prototype)console.log(Student.prototype.constructor)var s = new Student('liming',16)console.log(s.age)console.log(s.sayName()) ​ 这种方式是通过Object.create来实现构建原型链，其中Object.create(参数1，参数2); 参数1用作新对象的原型对象，参数2为新对象定义额外属性的对象。值得注意的是，这里有下面几种常见的错误写法： ​ Student.prototype = Person.prototype ​ 这里，Student.prototype不会单独创建一个新的内存，而是直接引用了Person.prototype，如果在这个时候我们改了Student.prototype的相关属性，Person.prototype也会被直接修改，故不能这样做。 ​ 第二种错误是Student.prototype = new Person()，这里，Student.prototype使用了Person的构造函数，后期会产生一些副作用，如果改变Person中的状态，会影响Student后代。 ​ 不过在ES6之后我们可以把Student.prototype = Object.create(Person.prototype)改写成Object.setPrototypeOf(Student.prototype,Person.prototype) 寄生组合式继承​ 这个方式是针对第一种方式的缺点进行的改造，实际上就是先获取父类的相关属性，再定义一个函数专门用于实现继承并修正的作用，具体实现如下所示： 1234567891011121314151617181920212223242526272829//寄生组合式继承function inheritProto(Sub, Super)&#123; //根据Super的原型创建一个新的对象proto var proto = Object(Super.prototype); //增强新对象，为其赋construtor值 proto.constructor = Sub; //将新对象赋值给子类的原型。 Sub.prototype = proto;&#125;//使用//Super中定义属性namefunction Super(name)&#123; this.name = name; this.color = ['red','green'];&#125;//Super的原型中定义方法Super.prototype.sayname = function()&#123; return this.name;&#125;function Sub(name, age)&#123; //通过构造函数的方式继承Super的属性,只在此处调用一次Super构造函数 Super.call(this, name); //定义自己的属性 this.age = age;&#125;//调用函数，实现继承。代替之前的Sub.prototype = new Super();语句，防止Super构造函数调用两次inheritProto(Sub,Super);var s = new Sub('liming',18)console.log(s.sayname())]]></content>
      <categories>
        <category>js基础知识</category>
      </categories>
      <tags>
        <tag>原型和原型链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从Url到页面加载的前端知识梳理]]></title>
    <url>%2F2018%2F11%2F22%2F%E4%BB%8EUrl%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[​ 之前在掘金上看了一篇文章，名为《从输入URL到页面加载的过程—如何由一道题完善自己的前端知识体系！》感觉对整个前端的流程，包括底层的一些工作原理讲的很系统。并融入了很多计算机网路的常识问题。借着给工作室做一次技术分享的机会，我想把相关的知识自己在整理下。 涉及到的知识​ 按照文章的整个结构，将整个从Url到页面加载分为以下的几个阶段： 从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系） 开启网络线程到发出一个完整的http请求（这一部分涉及到dns查询，tcp/ip请求，五层因特网协议栈等知识） 从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等） 后台和前台的http交互（这一部分包括http头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等） 单独拎出来的缓存问题，http的缓存（这部分包括http缓存头部，etag，catch-control等） 浏览器接收到http数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloaded等） CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC等概念） JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等） 其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容） 接下来的内容也会参考那篇博客，根据这几个点展开描述。 ###1.从浏览器接收url到开启网络请求线程 多线程的浏览器​ 浏览器也像一个操作系统一样，是个多进程的结构，他的每个tag页面都是一个进程，当然远不止这些，这些进程可能还会包括： 浏览器的主线程，复杂协调、主控 第三方插件进程：这种第三方的插件一般是一个进程，当然只有在插件被调用的时候被创建。 GPU进程：最多一个，用于3D绘制 浏览器的渲染进程（内核）：一般默认每个tab页面一个进程，互不影响，用于页面的渲染和脚本事件的执行。 多线程浏览器内核​ 正如操作系统中那样，浏览器的tab是一个进程，同时这个进程可能还会分为多个线程，具体可能有下面的进程： GUI线程 JS引擎线程 事件触发线程 定时器线程 网络请求线程 这里，js线程是一个线程存在的，所以我们常说js是个单线程的，他是和其他的线程（如时间触发线程，异步请求线程等）并发进行的。 解析Url在输入url确认后，浏览器会对其进行相关的解析，主要从下面的部分进行： protocol，协议头，譬如有http，ftp等 host，主机域名或IP地址 port，端口号 path，目录路径 query，即查询参数 fragment，即#后的hash值，一般用来定位到某个位置 之后会根据解析的结果，结合HTTP协议，开辟一个网络线程，生成请求去请求资源。 开启网络线程到发出一个完整的http请求DNS查询TCP建立连接和关闭连接从服务器接收到请求到对应后台接收到请求]]></content>
      <tags>
        <tag>前端基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式——观察者模式]]></title>
    <url>%2F2018%2F11%2F19%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[简介​ 观察者模式又称为发布—订阅模式，主要定义的是对象间一对多的关系。如果在关系中一个对象改变的时候，其他依赖的对象也能够及时得到这个对象的通知。这个用法实际上在JavaScript中也很常见，比如在Vue里面，多个组件监听一个变量的变化，当变量的值发生变化的时候，这些依赖的对象也能够很快得到这个值的变化从而重新渲染数据。 一个简单的实例我们先通过一个实例来说明这个观察者模式是怎样运行的： 12345678910111213141516171819202122232425262728var msgOffer = &#123;&#125;; //定义发布者var msgGetter = function(name)&#123; //定义接收者 this.name = name; this.listen = (type,msg) =&gt; &#123; console.log(this.name + '收到的消息是：' + msg) &#125;&#125;msgOffer.clientList = []; //定义收听者的回调函数msgOffer.addClient = function(func)&#123; this.clientList.push(func)&#125;msgOffer.sendMess = function()&#123; var num = this.clientList.length; for(let i = 0;i &lt; num;i++)&#123; func = this.clientList[i].listen; //这里调用apply函数可以给箭头函数传入当前环境this func.apply(this,arguments) &#125;&#125;var stu1 = new msgGetter('小明');var stu2 = new msgGetter('小红');msgOffer.addClient(stu1);msgOffer.addClient(stu2);msgOffer.sendMess('good','放假了');//执行的结果是//小明收到的消息是：放假了//小红收到的消息是：放假了 ​ 在上面这段代码里，首先我们定义了一个用来发送消息的对象msgOffer，也定义了一个接收消息的对象msgGetter。这里用name区分不同的收听者，并定义了他们的监听回调函数（回调函数使用箭头函数定义的，虽然箭头函数没有自己的this，但是在之后我们调用回调函数的时候使用apply可以给箭头函数定义一个环境this指向被调用的实例化对象）。之后向msgOffer添加了几个方法，一个是用来增加收听者的数组clientList，一个是用来发布消息的函数sendMess。发布消息的函数通过每次遍历收听者数组并调用他们的listen函数来调用回调函数。这样的话整个发布—订阅模式定义完毕。 能够选择性监听的观察者模式​ 上面的这段代码只是一个很简单的观察者模式，实际上他还是有很多设计上的问题。比如在上面，如果有的收听者只想接受特定的消息，比如在上述示例中，小明只想收听好消息，那么这个功能就需要加上去了。我们将代码改成下面这样： 12345678910111213141516171819202122232425262728293031323334var msgOffer = &#123;&#125;; //定义发布者var msgGetter = function(name)&#123; this.name = name;&#125;msgOffer.clientList = []; //定义收听者的回调函数msgOffer.addClient = function(obj,type,func)&#123; let client = &#123; obj:obj, type:type &#125; obj.listen = func; this.clientList.push(client)&#125;msgOffer.sendMess = function()&#123; var type = Array.prototype.shift.call(arguments) //取出消息的类型 var num = this.clientList.length; for(let i = 0;i &lt; num;i++)&#123; if(this.clientList[i].type == type)&#123; func = this.clientList[i].obj.listen var _that = this.clientList[i].obj; func.apply(_that,arguments) &#125; &#125;&#125;var stu1 = new msgGetter('小明');var stu2 = new msgGetter('小红');msgOffer.addClient(stu1,'good',function(msg)&#123; console.log(this.name + '收到的消息是：' + msg)&#125;);msgOffer.addClient(stu2,'bad',function(msg)&#123; console.log(this.name + '收到的消息是：' + msg)&#125;);msgOffer.sendMess('good','放假了');msgOffer.sendMess('bad','交作业') ​ 执行上面的这行代码，可以发现小明和小红收到了各自想要接受的消息类型。上面的这段代码在原来的基础上，在发布者里面clientList数组用来存放多个对象，这些对象都有一个obj属性和一个type属性，用来存放收听者对象和想要获得的消息的类型。在每次收听者订阅的时候，都会声明他想要收听的消息的类型，并且会传入一个事件处理函数。这样的话，在发布者每次发布消息的时候，都会发布这个消息的名称和内容，匹配到想要收听该类消息的收听者后，就会执行对应的回调函数。这样就实现了收听者对于消息的过滤。 使代码更通用​ 接下来我们做的事就是让这段代码更具有通用性。因为消息的发布者可能并不只是一个人，其他的对象也具有发布全体消息的功能，我们就对上面的代码进行一点修改使它更适用于更多的情况。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var eventer = &#123; clientList : [], addClient: function(obj,type,func)&#123; let client = &#123; obj:obj, type:type &#125; if(!obj.listen) &#123; obj.listen = func; this.clientList.push(client) &#125; &#125;, sendMess : function()&#123; var type = Array.prototype.shift.call(arguments) //取出消息的类型 var num = this.clientList.length; for(let i = 0;i &lt; num;i++)&#123; if(this.clientList[i].type == type)&#123; func = this.clientList[i].obj.listen var _that = this.clientList[i].obj; func.apply(_that,arguments) &#125; &#125; &#125;&#125;var msgGetter = function(name)&#123; this.name = name;&#125;var insert = function(obj)&#123; for(let i in eventer)&#123; obj[i] = eventer[i] &#125;&#125;var sendObj = &#123;&#125;var sendObj2 = &#123;&#125;insert(sendObj)insert(sendObj2)var stu1 = new msgGetter('小明');var stu2 = new msgGetter('小红');sendObj.addClient(stu1,'good',function(msg)&#123; console.log(this.name + '收到的消息是：' + msg)&#125;);sendObj.addClient(stu2,'bad',function(msg)&#123; console.log(this.name + '收到的消息是：' + msg)&#125;);sendObj2.addClient(stu1,'good',function(msg)&#123; console.log(this.name + '收到的消息是：' + msg)&#125;);sendObj2.addClient(stu2,'bad',function(msg)&#123; console.log(this.name + '收到的消息是：' + msg)&#125;);sendObj.sendMess('good','放假了');sendObj2.sendMess('bad','交作业') 取消订阅​ 有订阅就有取消订阅，当一个对象已经不需要依赖另一个对象的时候就需要取消对其的监听。代码如下所示： 12345678910remove : function(key,name)&#123; let len = this.clientList.length; for(let i = 0;i &lt; len;i++)&#123; //找到了对应的函数 if(this.clientList[i].type == key &amp;&amp; this.clientList[i].obj.name == name)&#123; this.clientList.splice(i,1) break; &#125; &#125;&#125; 将事件全局化​ 上述的代码已经基本实现了我们的要求，但是接下来我们想让这个时间的发布成为一个全局的事件，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var eventer = (function()&#123; var clientList = [],addClient,sendMess,remove; addClient = function(obj,type,func)&#123; let client = &#123; obj:obj, type:type &#125; if(!obj.listen) &#123; obj.listen = func; this.clientList.push(client) &#125; &#125; sendMess = function()&#123; var type = Array.prototype.shift.call(arguments) //取出消息的类型 var num = this.clientList.length; for(let i = 0;i &lt; num;i++)&#123; if(this.clientList[i].type == type)&#123; func = this.clientList[i].obj.listen var _that = this.clientList[i].obj; func.apply(_that,arguments) &#125; &#125; &#125; remove = function(key,name)&#123; let len = this.clientList.length; for(let i = 0;i &lt; len;i++)&#123; //找到了对应的函数 if(this.clientList[i].type == key &amp;&amp; this.clientList[i].obj.name == name)&#123; this.clientList.splice(i,1) break; &#125; &#125; &#125;; return&#123; clientList:clientList, addClient:addClient, sendMess:sendMess, remove:remove &#125;&#125;)()var msgGetter = function(name)&#123; this.name = name;&#125;var stu1 = new msgGetter('小明');var stu2 = new msgGetter('小红');eventer.addClient(stu1,'good',function(msg)&#123; console.log(this.name + '收到的消息是：' + msg)&#125;)eventer.addClient(stu2,'bad',function(msg)&#123; console.log(this.name + '收到的消息是：' + msg)&#125;)eventer.sendMess('good','放假了') 离线通知​ 当然，还有一种情况就是。当发布者发布消息的时候，可能收听者并不在线不能及时收听到。我们需要做的就是当用户上线的时候，消息能够传达到收听者。这个时候我们需要一个存放离线事件的堆栈，当事件发布的时候，如果这个时候还没有订阅者来订阅这个事件，我们就将发布事件的动作放在一个函数里，这些函数将会被存放在堆栈中，下一次有对象来访问的时候，就将他执行。]]></content>
      <categories>
        <category>javascript设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[前端菜鸡的算法——排序算法总结]]></title>
    <url>%2F2018%2F11%2F17%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[快速排序算法简介​ 快速排序也是一种分治的思想，和归并排序是互补的。归并排序是先进行递归操作之后在进行归并排序，而快速排序算法是先进行排序后递归操作。归并排序的时候，一般切分的位置恰好在数组的中心位置，但是快速排序的切分的位置是取决于数据的内容。 简单的思路​ 快速排序的思路是随机的取a[lo]为划分元素，之后指定两个左指针i和右指针j分别指向a[lo]以及数组的最后一个元素的下一个元素。然后开始左指针扫描，遇到比a[lo]大的元素就停止，右指针开始从后往前扫描，遇到比a[lo]小的元素就停止。然后左右指针指向的那个两个数相互交换位置，左指针又开始扫描，重复以上的过程，直到两个指针相遇为止。这样的话，所有在左指针的元素都比a[lo]小，在a[lo]右边的元素都比他大。最后再交换a[j]和`a[lo]，本次的整个过程排序完毕。接下来就是要把a[i]两边的数进行递归排序，直到递归到只剩一个数。 ​ 这是第四版算法对于整个快速排序的过程图示，其中，j代表了在每一次递归排序的结束的时候和a[lo]交换位置的那个数的地址。并且在每次排序的时候，大小为1的子数组由于lo == hi所以不进行排序。 代码的实现接下来是对上述算法的代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243package QuickSort;public class Quick &#123; public static void sort(int[] a)&#123; sort(a,0,a.length-1); &#125; public static void sort(int[] a,int lo,int hi)&#123; if (hi &lt;= lo)&#123; return; &#125; int j = partition(a,lo,hi); &#125; public static int partition(int[] a,int lo,int hi)&#123; int i = lo,j = hi + 1; int v = a[lo]; while(true)&#123; while(a[++i] &lt; v) if (i &gt;= hi) break; while(a[--j] &gt; v)&#123; if (j &lt;= lo)&#123; break; &#125; &#125; if (i &gt;= j) break; exchange(a,i,j); &#125; exchange(a,lo,j); return j; &#125; public static void exchange(int[] a,int i,int j)&#123; int temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; public static void main(String[] args) &#123; int arr[] =&#123;5,2,9,4,3,1,6,8,5&#125;; Quick.sort(arr); for (int i = 0;i &lt; arr.length;i++) System.out.println(arr[i]); &#125;&#125; 算法分析​ 快速排序算法相较于希尔排序算法和归并排序算法而言，其优势在于进行的时候主要是在和一个数进行比较，在内循环中不需要太多的移动。其次就是快排得到比较次数相较于其他的两个算法而言少了很多。排序的效率取决于划分的位置，接下来我们将要来探讨这个算法的时间复杂度的影响。 ​ 理想的情况下，快排的时间复杂度最好是每次划分的时候划分点正好位于数组的中心，即正好能够将整个数组对半分。这个时候快排的比较次数正好满足分治递归的$$C_n=2C_N/_2+N$$。那么这个时候$$C_N~Nlg_n$$.但是，并不是所有的情况都能使划分点恰好落在中心位置，这种情况总是以一定的概率出现的，这就需要我们去计算这个算法的平均消耗代价。 ​ 结论：长度为N的无重复数组排序，快排平均需要$$~2NlnN$$次比较。这里是根据相关的数学推导得到的，具体的推导过程在算法第四版的186页，这里不做深入的探究 快排的改进算法快排最糟糕的情况，无非就是当数组划分的时候不均匀，尤其是如果一个数组顺序的时候，可能会出现一边的数组总是空的的情况，这个时候的时间复杂度： ​ $$N+(N-1)+(N-2)+….+2+1=(N+1)N/2$$ ​ 也就是说算法比较的次数约在$$N^2/2$$这个级别上。这是一种相当糟糕的情况，但是可以将待排的数组打乱，这样将会把比较次数降低很多。 切换插入排序​ 通过实验发现，在数据量很小的情况下，快速排序的性能不如插入排序，所以我们可以考虑在快速排序到小数组的时候利用插入排序来解决排序问题。这样可以明显提升。一般可以把代码中的 123if (hi &lt;= lo)&#123; return; &#125; 更改为： 1234if (hi &lt;= lo + M)&#123; insertSort(a,lo,hi)； return;&#125; 三取样划分​ 我们也可以通过三取样划分来提升性能。这时候实际上是将数组划分为了三部分，并设置了三个指针lt,i和gt。a[lo...lt-1]是小于当前比较的数，a[`lt…i-1]一部分是等于当前比较的数，a[i…gt]一部分是不确定的元素，a[gt+1…hi]大于当前比较的数。初始化的时候，首先将lt置为lo，将i置为lo+1，将gt置为hi，之后开始进行比较。如果： a[i]小于v，将a[lt]和a[i]交换，并将lt和i加一 a[i]大于v，将a[gt]和a[i]交换，将gt减一 a[i]等于v，将i加一 具体的代码见下面所示： 12345678910111213141516171819public static void threeQuick(int[] a,int lo,int hi)&#123; if (hi &lt;= lo) return ; int lt = lo,i = lo + 1,gt = hi; int v = a[lo]; while(i &lt;= gt)&#123; if (a[i] &gt; v)&#123; exchange(a,gt,i); gt--; &#125; else if(a[i] &lt; v)&#123; exchange(a,lt,i); i++; lt++; &#125; else &#123; i++; &#125; &#125; threeQuick(a,lo,lt - 1); threeQuick(a,gt + 1,hi); &#125;]]></content>
      <categories>
        <category>数据结构与算法分析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Webpack个人总结]]></title>
    <url>%2F2018%2F11%2F12%2FWebpack%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[​ 之前学习webpack由于版本问题以及学习的知识比较零散，所以走过很多弯路，现在通过自己一些编程的实践和看相关的书籍博客，来总结下相关的知识点。主要还是为了再熟悉一下webpack相关的打包流程，以及这种模块化的思维。也是对Vue，react这种框架的一种更加深入的理解。 ​ 首先新建一个webpack的空文件，然后按照流程先npm init，代表的是新建一个package.json文件，之后需要确认一些参数，当然如果想要全部输入默认值跳过提问环节的话可以直接输入npm init -y。之后会生成一个package.json文件。在这个文件里面，我们更关心script这一部分的内容，为了尝试这个功能我们做一个调试。在script里面增加这个字段： 1"my": "node index.js" ​ 其实，这里使用到了Npm Script，他是一个任务的执行者。允许在package.json这个文件里面使用script字段来定义任务。相当于我们使用npm run加上定义的字段可以来执行相关的指令。比如在这里输入npm run my就相当于输入了node index.js。 ​ 之后安装webpack。接下来我们来配置webpack。首先创建一个webpack.config.js。然后在在这个文件中添加下面的内容： 1234567891011const path = require('path') //path是webpack中的基本包，处理路径const config = &#123; //入口文件 entry: path.join(__dirname, 'src/js/test.js'), //__dirname表示当前文件所在的目录地址，利用join()拼接成绝对路径 // 输出文件 output: &#123; filename: 'bundle.js',//输出文件名 path: path.join(__dirname, 'dist') &#125;&#125;module.exports = config ​ 现在新建一个src文件，并在里面新建js文件，里面有个test.js文件，里面放入下面的代码： 12import '../../index'console.log('this is test') ​ 然后在下方的命令行中输入webpack。就可以进行打包了。最后输出了一个dist文件夹，里面有一个bundle.js文件就有我们之前的js文件里面的东西,。而且由于在这个文件中我们import了另外一个.js文件，这个js文件中的内容也被打包放在了上面。 ​ 现在我们在这里引入css文件。首先我们先在src文件下新建一个style文件，里面放入一个test.css文件： 123body&#123; color: red&#125; ​ 由于在webpack里面，一切的文件类型都可以用js来打包，所以这里我们在js文件中import引入这个css模块，在index.js文件中引入这个文件： 1import './src/style/test.css' 引入后由于在webpack并不能解析CSS，我们需要借助Loader机制去实现。在webpack.config.js中增加下面的内容： 12345678module:&#123; rules:[ &#123; test: /\.css$/, use:['style-loader','css-loader?minimize'] &#125; ] &#125; 这里声明了一个rules，test用正则表达式用来匹配需要用loader转换的CSS文件。这里，style-loader是将CSS代码写入到了js中去，css-loader正是读取css文件的，minimize用来压缩css文件。也可以写成下面的形式： 123456789use:[ 'style-loader', &#123; loader:'css-loader', options:&#123; minimize:true &#125; &#125;] ​ 当然，如果将css代码放在js文件里面执行会导致js文件变大并且加载网页的时间变长，所以我们可以利用相关的插件将CSS文件单独分离出来。在webpack3一般用的是extract-text-webpack-plugin，但是很遗憾，这个在webpack4里面已经被废弃了，取而代之的是mini-css-extract-plugin。 12345678910111213module:&#123; rules:[ &#123; test: /\.css$/, use:[MiniCssExtractPlugin.loader,'css-loader?minimize'] &#125; ] &#125;, plugins:[ new MiniCssExtractPlugin(&#123; filename: 'css/[name].[contenthash:7].css' &#125;) ] 之后开始配置dev-server,现在script里面输入下面的内容： 12"build": "cross-env NODE_ENV=production webpack --config webpack.config.js","dev": "cross-env NODE_ENV=development webpack-dev-server --config webpack.config.js" 其实上面两个是设置了两个指令，NODE_ENV定义了他们一个是生产模式一个是开发模式。–config后面是设置了webpack的配置文件。cross-env是说可以跨平台使用。同时这里需要安装几个插件： 1npm i html-webpack-plugin webpack-dev-server cross-env 然后修改webpack配置文件中的设置，先定义一个变量判断当前的运行环境： 1const isDev = process.env.NODE_ENV === 'development' 然后下面根据当前环境判断是否启动： 12345678910111213141516171819202122if (isDev) &#123; config.devtool = '#cheap-module-eval-source-map' //帮助在页面上调试代码, 优化显示 config.devServer = &#123; port: 8088, //host 可以通过localhost进行访问，同时也可以通过本机的内网id进行访问，就能够在别的网页或者手机上访问 host:'0.0.0.0', //overlay 编译过程有任何错误都直接显示到网页上 overlay: &#123; errors: true &#125;, // 当修改组件代码时，只重新渲染当前组件，不会让整个页面重新加载；hot启动后要添加以下两个插件 hot: true // 能够在运行后直接打开浏览器 // open: true &#125; // 启动webpack.hot功能的插件 config.plugins.push( new webpack.HotModuleReplacementPlugin(), //启动hot功能 new webpack.NoEmitOnErrorsPlugin() //减少不需要信息的提示 )&#125; 这时候运行npm run dev就能正常启动服务器了，但是这样显示出来的只是一个这样的页面： 说明我们还没有一个初始化的HTML文件。所以为了让webpack-server有一个默认的页面，我们再用一个插件来快速生成： 1234567var HtmlwebpackPlugin = require('html-webpack-plugin');//....plugins: [ new HtmlwebpackPlugin(&#123; title: 'Hello World app' &#125;)//在build目录下自动生成index.html，指定其title ], 这时候通过npm run build我们其实可以看见在dist里面生成了一个index.html文件，里面是这样的： 123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Hello World app&lt;/title&gt; &lt;link href="css/main.7a0631b.css" rel="stylesheet"&gt;&lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript" src="bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ​ 可以看见，这里里面包含了刚刚我们打包的css和js代码。这是因为不配置任何选项的html-webpack-plugin插件，他会默认将webpack中的entry配置所有入口thunk和extract-text-webpack-plugin抽取的css样式都插入到文件指定的位置。]]></content>
      <categories>
        <category>web基础知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ES6语法——Set和Map数据结构]]></title>
    <url>%2F2018%2F11%2F11%2Fset%E5%92%8Cmap%2F</url>
    <content type="text"><![CDATA[Set的用法​ 在python语言中，Set实际上是一个新的数据结构名叫集合。正如同数学当中的集合一样，在集合中的所有成员的值都是唯一的，不能有重复。ECMAScript6也仿造了这一点有一个Set数据结构。通常是通过new一个Set类型的对象，然后向里面添加元素。如果有重复他会自动去删除这些相同的元素。 123const s = new Set();[6,8,1,5,6,2,3,4,5].forEach(num =&gt;s.add(num));console.log(s); ​ Set函数可以接受一个数组，或者是具有Iterable接口的其他数据结构皆可。最为其参数。然后用来初始化这个数据结构。同时在Set中添加值的时候不会进行变量的强制转化，5和”5”不是同一个值。同时NaN在这里被认为和其自生是相等的。但是，两个对象总是被认为是不相等的，比如两个空对象之间是不等的。使用Array.from方法可以将Set数据结构转换为常见的数组类型，这样也就实现了数组去重的功能。 Set数据结构可以有四个遍历成员的方法可供选择，具体就是： keys()：返回键名遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：利用定义的回调函数进行对成员的遍历。 ​ 由于Set没有键值对，所以其实keys()和values()返回的内容完全相等。entries()返回的键值对两个成员也是相等的。 WeakSet的用法WeakSet和Set类似，也是不重复值的集合，但是它和Set有以下的区别： WeakSet的成员必须是一个对象，不能是其他类型的值。 WeakSet中的对象都是弱类型的，因此在垃圾回收的时候是不会考虑WeakSet的引用问题。这是因为在垃圾回收的时候，机制是依赖于引用一个计数，从而判断当前这个变量被多少对象引用。如果这个值为0，垃圾回收机制就不会释放这块内存。这时候会存在一个问题，就是在垃圾回收的时候忘记取消对回收变量的引用，从而内存不能被释放，进而导致内存泄露。而WeakSet就不会存在这样的问题。他适合临时存放一组对象，并且存放跟这个对象绑定有关的信息。如果这个对象已经没有其他的引用，就会直接从WeakSet中消失。因此，WeakSet中变量的数量是取决于垃圾回收机制的运行，由于垃圾回收机制是不可预测的，所以ES6中不允许对WeakSet进行遍历。 Map的用法：在传统的语法中，JS的对象是键值对的集合，但是一般只能是字符串当作键来使用。为了解决这个问题，ES6提供了一个名为Map的数据结构，这里键可以是各种类型的值，包括类。 同时Map中接受数组作为参数，并读取相关的信息，其实任何具有Iterator接口，且成员一双元素出现的数据结构都可以作为Map构造函数的参数。 12345678const items = [ ['name','liming'], ['sex','man']]const map = new Map(items);console.log(map.get('name'))const m2 = new Map(map)console.log(map.get('name')) ​ 需要注意的是，只有对同一个对象的引用，Map才会将他们视作为同一个键，否则即使他们的名称一样，但内存地址不同也不能视为是同一个键。下面的这个例子说明了这个问题： 12345678910const map = new Map()const k1 = ['aa']const k2 = ['aa']map.set(['bb'],123)console.log(map.get(['bb']))map.set(k1,123)console.log(map.get(k1))map.set(k2,456)console.log(map.get(k2)) 这样也就就觉了同名的问题，只要地址不一样，就视为不同的两个属性。 当然，如果map的键是一个普通的简单值二点时候，只要两个严格相等，依然是视为同一个键。]]></content>
      <categories>
        <category>js基础知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[web缓存机制]]></title>
    <url>%2F2018%2F11%2F06%2Fweb%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[web缓存机制​ 在chrome的开发者工具中，在network /Size一列中可以看见一些请求，如果在 这列中明确标明大小KB,B，说明这是一个网络请求，否则一般都会明确标明：from memory cache,from disk cache和from ServiceWorker. 优先级依次是： Service Worker Memory Cache Disk Cache 网络请求 1、Memory Cache ​ 它是内存中的缓存，和硬盘中的缓存相对。几乎所有的网络请求资源都会被浏览器加入到memory cache中去，但由于数量大所以是个短期的存储过程。当浏览的TAB页关闭的时候就失效了。或者一个页面占用的缓存过多的时候会导致前面的TAB缓存还没关闭就失效了。 ​ （1）preloader ​ 一般浏览器在打开网站的时候都是请求js/css，之后解析执行，然后再次解析下一个请求这样的穿行操作，那么现在，能不能一边解析js/css，一边请求下一个资源，这就是preloader所干的事。memory cache机制保证了一个页面中若有两个相同的请求的时候，（比如有两个相同href的)都实际上只进行一次请求。在匹配缓存的时候，除了会对他们的URL进行匹配。也会对他们的类型、CORS中的域名规则进行校对。比如在script中缓存的资源不能用在image图片类型的请求中，即使他们的src相同。 ​ （2）从memory cache中获取缓存内容的时候，浏览器自动忽略max-age=0,no-cache这些头部配置。因为memory cache只是短时间使用，大部分生命周期只有一次。max-size意思也就是“不要在下次浏览时使用”，和memory cache不冲突。如果真的不想让一个资源进入缓存，即使一次都不想，就可以使用no-store。这样memory cache就不会存储它了 2、disk cache ​ 也叫HTTP cache，是存储在硬盘上的缓存，是持久存储的，实际存在于文件系统当中。允许相同资源跨会话，甚至站点进行使用。他会严格根据HTTP头部信息进行判断哪些资源缓存，哪些可用，哪些过期了需要重新发送请求。命中之后浏览器会从硬盘中去读取资源，虽然过程会比内存中读取慢但是比网络请求快很多。一般大部分的缓存都是来自disk cache。 3.Service Worker ​ 以上的缓存机制和读取，缓存以及失效的行为都是通过浏览器判断进行的，只能通过设置响应的头部告诉浏览器应该做什么。而Service Worker就是一种更直接的方式，这个缓存是永久的，即使关闭TAB或者是关闭浏览器都不能将其删除。只有以下两种情况才会将其删除：手动调用API：cache.delete(resource)或者容量溢出。会被浏览器清除。如果Service Worker没有命中，就会调用fetch()方法继续获取资源。虽然这个时候没有命中Service Worker缓存，用了网络请求，但是在Chrome中依然会被标记为from Service Worker。 4.请求网络 ​ 如果前面的三个缓存都没有命中，那么就通过网络请求的方式获取。但是在获取完成之后，需要处理如何将这个资源放在缓存中去的问题： 根据Service Worker中的handle决定是否存入Cache Storage(额外的缓存位置)。 根据HTTP头部的相关字段决定是否存入disk cache memory cache 保存一份资源 的引用 开发与应用简单的实例​ 在浏览器端对web的存储，一般都会在Windows上定义两个属性：localStorage和sessionStorage。他们都代表同一个持久化的关联数组，这个数组使用字符串来进行索引，并且在里面存储的所有的数都是以字符串的形式呈现。 ​ 接下来我们来通过实例来讲述对于web缓存中在编程上的简单运用。首先我们先来测试一下localStorage这个方法： 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script&gt; var number = 10; localStorage['number'] = number; console.log(localStorage['number']) console.log(typeof(localStorage['number']))&lt;/script&gt;&lt;/html&gt; ​ 这段代码最终的输出是10和string，首先我们定义了一个number，并且在localStorage中的number索引中存放了一个之位10的数。之后将这个值打印出来，可以看见，虽然在我们定义的时候这个number的类型是一个整形的数，但是在存储的时候localStorage将其存储为一个字符串型的数，这对sessionStorage来说也是一样的。并且对于localStorage而言，这个值只要我们不去手动调用相关的函数或是去进行相关的操作删除，他会一直保留在浏览器中。这也就是localStorage和sessionStorage两者的区别。 存储的有效期和作用域​ 上面说到，localStorage的作用域是永久的，永不过期。他的作用域是限定在文件源级别的。 文档源是通过协议、主机名以及端口三者来确定的。比如下面的例子中每个文档源都是不同的： http://www.baidu.com //协议：http 主机名：www.baidu.com https://www.baidu.com //不同的协议 http://wap.baidu.com //不同的主机名 http://ww.baidu.com:8080 //不同的端口 ​ 在同源文档中共享同样的localStorage数据。可以相互之间进行读写和覆盖对方的数据。但是非同源数据之间就不能够读取或者覆盖。 ​ 但是sessionStorage就不一样了。他的有效期是伴随着存储数据的脚本所在的最顶层窗口或是浏览器标签页一 致。如果窗口或者标签页被关闭，那么存储的数据也会被删除。（一些支持回复上次会话的浏览器可能存储的时间会更久点）。同样，sessionStorage的作用域也是限定在文档源中。但是不一样的是，sessionStorage是限定在窗口中的。即使是同源文档但是被渲染到了不同的浏览器标签页（不包括两个iframe元素）的时候，他们互相拥有的是各自的sessionStorage数据，且在这些标签页之间不能共享。互相之间不能进行读写或者覆盖。 存储事件​ 对于web存储来说还有一个存储事件的监听函数addEventListener()方法，如果一个页面改变了一个值的时候，在另一个标签页中也会收到一个存储时间。对于session而言则是只有两个有牵连的窗口才会触发存储事件。在监听事件的回调函数的参数有几个属性，具体可以查阅相关文档。需要注意的是：localStorage和存储事件是采用的广播机制，浏览器会对访问相同站点的所有窗口发送消息。 cookie相关的介绍​ cookie是Web浏览器存储的少量数据，也具体的页面或者站点相关。从底层上讲是一种http协议的一种扩展。cookie是可以在Web浏览器和服务器之间传输的，服务器脚本也可以读写客户端的cookie。 cookie的相关属性：​ cookie具有名和值，还有一些可选的属性设置cookie的有效期和作用域。cookie的作用域只持续在Web浏览器的会话期间，关闭浏览器，cookie就会自动丢失。素以可以通过设置cookie的有效期来延长cookie的有效期。一旦设置，浏览器就会将cookie数据存储在文件中，等到超过了有效期就会删除。同样，cookie的作用域也是通过文档源和文档路径来确定。当然，也可以通过设置cookie的路径(path属性)让其他的页面也能够访问到。比如，对于http://www.baidu.com而言，如果路径是&quot;/cate&quot;，那么http://www.baidu.com/cate/index.html等都能够访问，如果直接将路劲设置成&quot;/&quot;，那么”http://www.baidu.com/index.html“也可以进行访问。并且，cookie也能实现不同域下的服务器之间读取同一个cookie，只需要设置cookie的domain属性就可以。同时，cookie还有一个属性叫做&quot;secure&quot;，表示的是cookie的值以何种形式通过网络传递。默认是通过不安全的形式（HTTP）传递。但如果标记成&quot;安全的&quot;，就只能通过HTTPS或者其他的安全协议连接传递。 保存cookie​ 设置默认的cookie形式就是：name=value。因为cookie中的名或者值是不允许有分毫，逗号或者空白符出现，所以一般存储前需要用JavaScript全局函数encodeURIComponent()进行编码。读取的时候也需要采用decodeURIComponent进行解码。如果想要延长生命周期的话需要用max-age进行指定有效期，设置的单位是秒。之后在读取cookie的时候通过一个例子来说明cookie的存取。 cookie的读取​ 利用JavaScript读取cookie的时候，返回值一般都是一个字符串，并且是由一串的名和值组成的，不同的对之间使用分号和空格分开，所以需要用split()将其分开。因为前面提到解码问题，所以这时候还需要通过decodeURIComponent进行解码，然后利用JSON.parse()转换成json对象。下面的这个例子说明了函数是如何进行存取cookie的： 1234567891011121314151617function setCookie(name,value,time)&#123; var cookie = name + "=" + encodeURIComponent(value); cookie += "; max-age=" + time; console.log(cookie) document.cookie = cookie console.log(document.cookie)&#125;function getCookie()&#123; var cookie = &#123;&#125;; var all = document.cookie; console.log(all) var list = all.split(" ; ") console.log(list)&#125;setCookie('liming',55,120)getCookie()]]></content>
      <categories>
        <category>web基础知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js代理]]></title>
    <url>%2F2018%2F11%2F04%2Fjs%E2%80%94%E2%80%94%E9%97%AD%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[js——闭包问题一、理解闭包首先根据下面的例子来理解闭包的概念： 1234567891011121314151617var ourVar = 'liming'var later;function outerTest()&#123; var inner = 'haha'; function innerTest()&#123; console.log(inner); console.log(ourVar) &#125; later = innerTest;&#125;outerTest();later();//运行的结果是：//haha//liming 在上面的代码中，在外部函数我们声名了一个变量inner，然后又声名了一个内部函数innerTest，接下来在内部函数中访问全局变量ourVar和函数内的变量inne，之后为了在全局中能够调用这个内部函数，在全局变量中设置了一个变量接受这个函数，通过调用outerTest创建内部函数并将内部函数赋给later，之后调用later。可以看见，即使现在内部作用域消失在执行内部函数时，内部变量依然存在。 这是因为在外部函数声明内部函数的时候，不仅定义了函数的声明，而且创建了一个闭包。闭包不仅包含了函数的声明，还包括了在函数声明时该作用域的全部变量。在执行内部函数的时候，虽然作用域已经消失，但是通过闭包，还能访问原始的作用域。 二、使用闭包1.封装私有变量虽然JavaScript不支持私有变量，但我们可以利用闭包的特性来实现私有变量的基本功能。 12345678910111213141516171819function student()&#123; var age = 23; this.name = "liHua" this.getAge = function()&#123; return age; &#125; this.increase = function()&#123; age++; &#125;&#125;var stu1 = new student();console.log(stu1.age)console.log(stu1.name)console.log(stu1.getAge())//运行结果//undefined//liHua//23 上述代码中，我们定义了一个age作为student类中的私有属性。由于js的作用域规则的限制，只能在构造器内部访问该变量。所以直接访问stu1.age执行的结果就是undefined。为了让外界可以接触这个变量，可以利用getAge来向外暴露。虽然这时候，函数的作用域结束了，但实例化对象通过this拥有这个作用域，所以可以访问他的方法。注意这里直接var定义的属性和利用this定义的属性是不一样的。]]></content>
      <categories>
        <category>javascript高级特性</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[生成器和Promise]]></title>
    <url>%2F2018%2F11%2F04%2Fjs%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8Cpromise%2F</url>
    <content type="text"><![CDATA[一、生成器函数类似于python，js也有自己的生成器，其基本的使用和定义方式如下所示： 123456789function* myGenertor()&#123; yield 'test1'; yield 'test2'; yield 'test3';&#125;for(let aa of myGenertor())&#123; console.log(aa)&#125; 最后，这个程序依次输出的是test1.test2和test3，这也是JavaScript的一个生成器。在定义函数的时候在function后面加一个*表示这是一个生成器函数，并通过关键字yield返回相应的值。并且，对于生成器函数来说，它不会像普通函数一样停止执行，而是当一个值的请求到来后，生成器就会从上次离开的地方继续开始执行。示例如下： 1234567891011function* myGenertor()&#123; var bb = 1; yield bb; bb++; yield bb; yield bb; &#125; for(let aa of myGenertor())&#123; console.log(aa) &#125; 从上面这个例子可知，第一次调用myGenenrtor这个生成器函数的时候，首先定义了一个名为bb的变量并且初始化为1，然后将这个值返回。第二次调用的时候，生成器不会像普通函数那样，再次从函数的开始执行，而是从上次执行的语句之后又开始执行b++，并返回此时bb的值为2.然后继续这个过程，返回的值是3.在这里，for-of循环就是对迭代器进行迭代的语法糖。 二、通过迭代对象控制生成器首先看下面这个例子 123456789101112131415161718function* myGenertor()&#123; var bb = 1; yield bb; bb++; yield bb; &#125; var myIterator = myGenertor();console.log(myIterator);console.log(myIterator.next())console.log(myIterator.next())console.log(myIterator.next())//执行的结果为//&#123;&#125;//&#123; value: 1, done: false &#125;//&#123; value: 2, done: false &#125;//&#123; value: undefined, done: true &#125; 在上面这个例子中，依然定义了一个生成器函数myGenertor，接下来调用这个生成器函数，但这一次赋给了一个名为myIterator的一个变量，如果直接输出这个变量，得到的是一个空的对象，只有对这个对象执行接口方法next(),生成器才开始执行代码，当代码执行到yield关键字的时候，生成一个中间结果并且返回一个新的对象，其中封装了一个结果值和指示完成的指示器。每当生成器生成一个值之后，生成器就会非阻塞挂起，等待下一次请求的到达。当没有可执行的代码的时候，生成器就会返回一个value为“undefined”，done为true的值，表示他的状态已完成。 三、利用生成器函数把执行权交给下一个生成器123456789101112131415function* myGenerator(action)&#123; const imposter = yield("hello" + action); //第二次next开始执行 console.log(imposter) yield("nihao (" + imposter + ")" + action);&#125;const test = myGenerator("test1");console.log(test.next())console.log(test.next("myotherTest"))//执行结果：// &#123; value: 'hellotest1', done: false &#125;// myotherTest// &#123; value: 'nihao (myotherTest)test1', done: false &#125; ​ 上面这个实例中，在迭代器上使用yield*操作符，程序会跳转到另一个生成器上执行，这一切对于最初调用的迭代器而言都是透明的。 四、迭代器与生成器之间的交互现在来讨论以下迭代器与生成器的交互问题，从而更好的理解生成器与迭代器之间的关系。首先先来看下面这段代码： 123456789101112131415function* myGenerator(action)&#123; const imposter = yield("hello" + action); //第二次next开始执行 console.log(imposter) yield("nihao (" + imposter + ")" + action);&#125;const test = myGenerator("test1");console.log(test.next())console.log(test.next("myotherTest"))//执行结果：// &#123; value: 'hellotest1', done: false &#125;// myotherTest// &#123; value: 'nihao (myotherTest)test1', done: false &#125; ​ 这里，我们给生成器一个参数action。首先新建一个迭代器并赋给test这样的一个变量。并且这个时候，我们已经给myGenerator赋予了一个参数，所以在下一次调用的时候，会输出”hello”加上这个参数。之后，生成器就在yield这里被挂起，imposter始终都没有被赋值直到下一次再次调用next()的时候，此时imposter被赋予了next中的值，这里是因为yield的返回值就是下一次调用next()的参数，所以imposter就被赋值。这也是为什么不能通过第一次调用next()向生成器提供参数的原因，但还是可以在构造的时候提供初值。（构造的时候仅仅是给参数赋值，但生成器函数是不会运行的） 五、生成器异常和处理123456789101112131415function* myGenerator(data)&#123; try&#123; yield "hello"; &#125;catch(e)&#123; console.log("出错了！！" + e) &#125;&#125;const test1 = myGenerator();console.log(test1.next());test1.throw("迭代器抛出了一个错误");// 运行结果：// &#123; value: 'hello', done: false &#125;// 出错了！！迭代器抛出了一个错误 ​ 这里将生成器中全部的代码装入try-catch块中去。在创建了迭代器之后，通过调用迭代器中的throw方法抛出异常，并利用生成器函数中的catch语句进行异常的接受和处理。 六、promise和生成器解决异步问题首先测试下面的这段代码： 12345678910111213141516171819function delay(time)&#123; var promise = new Promise(function(resolve,reject)&#123; setTimeout(resolve,time) &#125;) return promise;&#125;function* test()&#123; yield delay(300).then(() =&gt; console.log(1)); yield console.log(2) yield delay(300).then(() =&gt; console.log(3)); yield console.log(4)&#125;const a = test()a.next();a.next();a.next();a.next();//输出为2，4，1，3 由于在生成器中存在异步操作，所以在使用next操作的时候，会存在异步问题。这时候检查第一个a.next()的返回值的时候，可以看到返回以下的结果： 12&#123; value: Promise &#123; &lt;pending&gt; &#125;, done: false &#125;1 说明，对于一个promise，它的then()函数的返回值同样是一个promise对象。利用这个特性，将下次想要顺序执行的同步操作中的值放在promise函数的then之后，就可以得到我们想要的结果。 1234567const a = test()a.next().value.then(() =&gt; &#123; a.next() a.next().value.then(() =&gt; &#123; a.next() &#125;)&#125;) 可以发现，如果在遇到异步请求的时候，就使用.then()，如果遇到同步操作，就直接next()即可，所以可将上述代码整理成为下面的方法，利用递归来实现这个过程： 12345678910111213function himmel(gen) &#123; const item = gen.next() if (item.done) &#123; return ; &#125; const &#123; value, done &#125; = item if (value instanceof Promise) &#123; value.then((e) =&gt; himmel(gen)) &#125; else &#123; himmel(gen) &#125;&#125; 最终，执行的结果就是按照顺序执行的1，2，3，4​ ###番外 异步问题的另一种解决方案——利用闭包来实现： 首先还是先看下面这个异步的例子： 123456789101112131415161718192021222324252627282930313233function delay(time)&#123; var promise = new Promise(function(resolve,reject)&#123; setTimeout(resolve,time) &#125;) return promise;&#125;function test()&#123; for(var i = 0;i &lt; 5;i++)&#123; delay(300).then(function()&#123; console.log('这是第' + i + '一段输出'); &#125;) console.log('这个应该在第' + i + '次异步操作执行结束后才输出') if(i == 4)&#123; console.log('end') &#125; &#125;&#125;test()//运行结果//这个应该在第0次异步操作执行结束后才输出//这个应该在第1次异步操作执行结束后才输出//这个应该在第2次异步操作执行结束后才输出//这个应该在第3次异步操作执行结束后才输出//这个应该在第4次异步操作执行结束后才输出//end//这是第5一段输出//这是第5一段输出//这是第5一段输出//这是第5一段输出//这是第5一段输出 ​ 上面的代码是一个典型的异步的问题，由于delay()是一个异步操作，所以在程序运行到delay的时候，将这个操作放在异步事件的队列中，先去进行同步操作，于是本该在异步操作执行结束之后执行的语句被优先执行了。并且程序在异步操作还没来得及开始就宣布结束了。并且之后，由于全局变量中的i已经增加到了5，所以最后得到的都是5，这显然不是我们预期的结果。首先解决i的问题，这里需要加一个闭包，将每次执行的i纪录下来，并且利用递归，在每次异步操作回调之后在递归下一次的操作，直到达到程序的终点为止。这样也就完成了程序从异步变为同步的操作。具体代码如下所示： 12345678910111213141516171819202122232425262728293031323334function delay(time)&#123; var promise = new Promise(function(resolve,reject)&#123; setTimeout(resolve,time) &#125;) return promise;&#125;function test()&#123; (function iter(i)&#123; delay(300).then(function()&#123; console.log('这是第' + i + '一段输出'); console.log('这个应该在第' + i + '次异步操作执行结束后才输出') if(i == 4)&#123; console.log('end') &#125;else&#123; iter(i+1) &#125; &#125;) &#125;)(0)&#125;test()//运行结果：//这是第0一段输出//这个应该在第0次异步操作执行结束后才输出//这是第1一段输出//这个应该在第1次异步操作执行结束后才输出//这是第2一段输出//这个应该在第2次异步操作执行结束后才输出//这是第3一段输出//这个应该在第3次异步操作执行结束后才输出//这是第4一段输出//这个应该在第4次异步操作执行结束后才输出//end]]></content>
      <categories>
        <category>javascript高级特性</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js实现继承]]></title>
    <url>%2F2018%2F11%2F04%2Fjs%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF(%E5%BE%85%E4%BF%AE%E6%94%B9)%2F</url>
    <content type="text"><![CDATA[js实现继承一、尝试实现原型继承 123456789101112function Person()&#123;&#125;Person.prototype.dance = function()&#123;&#125;;function Ninja()&#123;&#125;Ninja.prototype = new Person();const ninja = new Ninja();console.log(ninja instanceof Ninja); //trueconsole.log(ninja instanceof Person) //trueconsole.log(ninja instanceof Object) //true 当定义一个Person函数的时候，同时也创建了一个Person原型，该原型通过其construtor属性引用函数的本身。同时下面也扩展了Person原型，加入了相关的方法。后面我们也定义了一个Ninja函数，并且该函数原型也有一个constructor属性引用函数本身。为了实现继承，将Ninja的原型赋为Person的实例。之后每创建一个Ninja对象的时候，新创建的Ninja对象将设置为Ninja的原型属性所指向的对象，即Person。 当访问Ninja对象的dance方法时，js首先会查找Ninja对象本身。没有就会找他的原型即Person。Person不具有dance方法就会再接着查找Person对象的原型，这时候找到了dance方法。执行instance操作符的时候，可以判定函数是否继承原型链上的对象功能。 其实实现继承还可以直接使用Person的原型对象作为Ninja的原型，如Ninja.prototype = Person.prototype。这样做会导致Person原型上发生的所有变化都被同步到Ninja原型上（Person原型和Ninja原型是同一个对象），会有一定的副作用。 constructor属性的问题​ 仔细观察可以发现，上述代码中，会存在丢失Ninja与Ninja初始原型的之间的关联，这是一个问题。如果利用constructor检查一个对象是否由某一个函数创建的时候，去检查Ninja会得到的是Person。显然这个答案是错误的。 配置对象的属性在js中，对象是通过属性描述的，可以通过配置一下关键字： configurable——如果设置为true，则可以修改或删除属性。 enumerate——如果如果设置为true，则可在for-in循环对象属性出现 value——指定其属性的值 writable——如果为true，可以通过赋值语句修改属性值 get——定义getter函数，当访问属性时发生调用，不能与value和writable同时使用。 set——定义setter函数，当对属性赋值的时候调用，不能与value和writable同时使用。 当然，可以使用内置的Object.defineProperty方法属性定义一个属性： 123456789101112131415var ninja = &#123;&#125;;ninja.name = "haha";ninja.sex = 'man';Object.defineProperty(ninja,'test',&#123; configurable:false, writable:true, value:false, enumerable:false&#125;);console.log('test' in ninja) //truefor(let m in ninja)&#123; console.log(m) //name,sex&#125; 利用上面的方法，就可以解决constructor被覆盖的问题，即通过Object.defineProperty在Ninja.defineProperty上定义一个constructor属性。 instanceof操作符在上面的例子中，虽然Ninja的原型是Person，但是通过instanceof还是可以发现ninja instanceof Ninja的返回值是true，说明ninja也是Ninja的实例。在这个过程中，javascript首先检查Ninja函数的原型——new Person()对象，检查他是否存在ninja的原型链上。由于new Person()对象确实是ninja的原型，所以表达式为true。实际上，ninja实例的原型链是由new Person（）对象和Person的原型组成的。 ES6语法中使用class关键字：1234567891011class test&#123; constructor(name)&#123; this.name = name; &#125; swing()&#123; return true; &#125;&#125;var haha = new test('tom');console.log(haha.swing()) 从上面的代码可以看出，ES6语法支持使用类似其他面向对象语言的方式用class来定义一个类。但实际上，class只是个语法糖，底层仍是基于原型的实现。上述定义类可转换成下面的ES5代码： 123456function Ninja(name)&#123; this.name = name;&#125;Ninja.prototype.swing = function()&#123; return true;&#125; 同时在ES6中还支持定义像Java一样的静态方法。 123456789101112131415class test&#123; constructor(name)&#123; this.name = name; &#125; swing()&#123; return true; &#125; static sum(x,y)&#123; return x + y; &#125;&#125;console.log(test.sum(1,2))var haha = new test('tom');console.log(haha.swing()) 实现继承js也可以像java一样利用extends来实现继承： 12 在student构造器中通过关键字super调用基类Person的构造函数。]]></content>
      <categories>
        <category>javascript高级特性</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js代理]]></title>
    <url>%2F2018%2F11%2F04%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1.保护代理和虚拟代理在前面的js学习中，ES6语法里有个proxy对象可以创建一个代理，可以通过代理实现控制不同权限的对象对目标对象的访问，从而实现对一些对象访问的过滤。虚拟代理的意思是，把一些开销大的对象，放在真正需要她的时候去创建。这是为了系统性能和一些特殊需要的考虑。由于js不容易判断是哪个对象访问了目标，所以JavaScript中不容易实现保护模式。常用的还是虚拟代理。 2.利用虚拟代理实现图片的预加载在web开发时，如果给一个图片直接设置一个src属性，常常会因为网络状况的异常导致图片无法正常加载。所以一般刚打开的时候会发现里面都是空白。为了解决这个问题一般就是会用一张预加载的图片占位，异步加载图片。一直等到图片加载完成之后就将其渲染到组件中去。]]></content>
      <categories>
        <category>javascript高级特性</category>
      </categories>
      <tags>
        <tag>JavaScript设计模式</tag>
        <tag>虚拟代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[懒加载与预加载]]></title>
    <url>%2F2018%2F11%2F04%2F%E6%87%92%E5%8A%A0%E8%BD%BD%E4%B8%8E%E9%A2%84%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[懒加载和预加载都是前端性能优化中对于图片的优化。从而使得用户有更好的上网体验 一、懒加载 1.1HTML中的懒加载方式 懒加载就是在延迟加载。一般的做法是不设置或者设置一个相同的图片src用来占位。并且将真正需要加载的图片地址放在img标签自定义的属性中（如：data-origin）。正如很多电商平台的做法，等到用户将浏览器的时候滑至该图片的位置上时，这时候由js监听并且将自定义属性中的值存放在src中。这时候图片才开始加载。由此达到懒加载的效果。这样做的目的也是为了防止页面一次请求浏览器的数据量服务的数据量过大导致后面的一些js因为图片的渲染迟迟不能被执行导致出现一些错误，同时也能够防止服务器响应慢，卡顿的问题。而且一般情况下用户访问页面的长度不会太大，如果都一次性请求所有的资源的话会造成很大的带宽浪费。所以才会采用懒加载的方式进行。这样可以避免很多无效的请求和加载。 懒加载的具体步骤是： 在图片的img标签里src置为空或者直接防止一个默认的地址，真正的地址放在自己定义的标签属性名里。 页面加载完成后，根据用户的滑屏情况进行判断图片的位置是否在用户当前的视野内。如果在，就将data-origin置为真实的值。 当用户滑动视野的时候判断图片是否进入视野，如果进入就将data-origin的值放在src中，并且将之前自定义的属性删除。 接下来通过一个实例来说明懒加载判断图片是否进入可视范围从而加载图片。 12345678910111213141516171819202122232425262728293031323334353637&lt;body&gt; &lt;div id="root"&gt;啊啊啊啊啊啊A啊啊啊啊啊&lt;/div&gt; &lt;!-- 若干行标签 --&gt; &lt;div id="root"&gt;啊啊啊啊啊啊A啊啊啊啊啊&lt;/div&gt; &lt;img src="" class="image-item" lazyload="true" data-original="http://pic26.nipic.com/20121213/6168183_004444903000_2.jpg" /&gt;&lt;/body&gt;&lt;script&gt;var viewHeight = document.documentElement.clientHeight // 可视区域的高度function lazyload () &#123; // 获取所有要进行懒加载的图片 var eles = document.querySelectorAll('img[data-original][lazyload]') Array.prototype.forEach.call(eles, function (item, index) &#123; console.log(item) var rect if (item.dataset.original === '') return rect = item.getBoundingClientRect() // 图片一进入可视区，动态加载 if (rect.bottom &gt;= 0 &amp;&amp; rect.top - 40&lt; viewHeight) &#123; !function () &#123; var img = new Image() img.src = item.dataset.original img.onload = function () &#123; item.src = img.src &#125; item.removeAttribute('data-original') item.removeAttribute('lazyload') &#125;() &#125; &#125;)&#125;// 首屏要人为的调用，否则刚进入页面不显示图片lazyload()document.addEventListener('scroll', lazyload) 首先这里定义了很多个div标签，是得在最下方的图片由于不在视野范围内所以暂时不进行加载。等到当用户滑动屏幕到图片的上边位置距离视野上方位置50像素的时候，图片的src被设置，同时进行没图片的加载。这里就实现了这个图片的懒加载。这楼里需要注意的是，在监听用户滑动的时候，我们用到了getBoundingClientRect这个函数，起作用是获取某个元素相对于视窗的位置。获得的都是某个元素的上下左右距离上边试图或者左边视图的距离。 1.2Vue上实现的懒加载 在Vue中，懒加载一般会使用插件vue-lazyload来实现，首先需要安装这个插件 1npm install vue-lazyload 在入口文件main.js中直接引用并使用。 1import VueLazyLoad from 'vue-lazy 之后在这里直接使用这个模块： 1Vue.use(VueLazyLoad) 当然也可以根据官方文档中提供的API自定义选项： 1234Vue.use(VueLazyLoad,&#123; error:'dist/error.png', loading:'dist/loading.png'&#125;) 同时在标签上修改图片的显示方式为懒加载的方式,注意这里是直接将src改成v-lazy： 1&lt;img v-lazy="/static/img/"+item.productImage/&gt;]]></content>
      <categories>
        <category>Web性能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js代理]]></title>
    <url>%2F2018%2F11%2F04%2Fjs%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[1、使用代理控制访问 ​ 代理是ES6语法提出的，是我们通过代理控制对另一个对象的访问。可以将代理理解为通用化的setter和getter方法，区别就是每个setter和getter只能控制单个对象的属性，而代理可用于对象交互的通用处理，包括调用对象的方法。首先先看下面的这个例子。 1234567891011121314151617181920212223242526272829303132const people = &#123; name:'liming'&#125;const father = new Proxy(people,&#123; get:(target,key) =&gt; &#123; console.log(target[key]) if(key in target) return target[key] else&#123; console.log('The value do not exits'); return undefined; &#125; &#125;, set:(target,key,value) =&gt; &#123; console.log('Something changed'); target[key] = value; &#125;&#125;)console.log(father.name)father['name'] = "mingming"console.log(people.name)console.log(father.ta)// 执行结果// liming// liming// Something changed// mingming// undefined// The value do not exits// undefined 这里我们定义了一个people对象，并设置了他的代理father，并且在father中指定了getter和setter方法。首先先查看father的名称，这时候会触发father的getter并返回名称。如果这里在getter中不返回，在console.log返回将会是undefined。之后对father进行了赋值，调用了father的setter方法，并将target即people的name属性进行了重新设定。之后又对原来people中不存在的一个变量ta进行访问，这时候还会去调用getter方法，然后检查key不在target对象中的时候就会返回一个undefined。 2、使用代理的优化代码 简单的说明 使用代理同时还可以优化代码。在不使用代理的时候，对一个对象的设置需要进行很多次的defineProperty的设置，如果需要为一个对象添加很多属性的时候就显得很多。但是利用了代理就能够很方便的解决这些问题。 123456789101112131415161718192021222324252627282930313233343536function makeConstructor(target)&#123; return new Proxy(target,&#123; get:(target,property) =&gt;&#123; console.log('Get function invoked') return target[property]; &#125;, set:(target,property,value) =&gt; &#123; console.log('Set function invoked'); target[property] = value; &#125; &#125;)&#125;let peo = &#123;name:'Yoshi'&#125;peo = makeConstructor(peo);console.log('分割线1')console.log(peo.name)console.log('分割线2')peo.weapon = 'shui'console.log('分割线3')console.log(peo.weapon)console.log('分割线4')console.log(peo)// 运行结果：// 分割线1// Get function invoked// Yoshi// 分割线2// Set function invoked// 分割线3// Get function invoked// shui// 分割线4// Get function invoked// Get function invoked// Get function invoked 首先定义了一个构造器，使用了一个对象target作为被代理的对象。然后调用了makeConstructor来构造对象和代理之间的关系，并在makeConstructor返回了新建的代理，并设置了相关的一些方法。然后可以发现，最开始对象只有一个name属性，在访问的时候会触发getter方法并返回它的值。之后对peo对象中之前不存在的一个属性weapon进行了设置，这时候可以看见触发了setter方法，并在对象中添加了一个名为”weapon”属性。之后又查看了刚刚添加的weapon方法。在最后可以看见，我们console.log输出peo这个对象，结果发现调用了三次get方法。为了探究我们对get方法进行一些处理。 node中运行代码的不同探究 12345678910111213141516171819202122232425262728function makeConstructor(target)&#123; return new Proxy(target,&#123; get:(target,property) =&gt;&#123; //console.log(property) console.log('Get function invoked') return target[property]; &#125;, set:(target,property,value) =&gt; &#123; target[property] = value; &#125; &#125;)&#125;let peo = &#123;name:'Yoshi'&#125;peo = makeConstructor(peo);peo.weapon = 'shui'peo.weapon1 = 'shui'peo.weapon2 = 'shui'console.log(peo)// //运行的结果：// Get function invoked// Get function invoked// Get function invoked// &#123; name: 'Yoshi',// weapon: 'shui',// weapon1: 'shui',// weapon2: 'shui' &#125; 刚开始我的理解是在输出peo的时候，首先对peo这个类整体的访问会触发一次getter，之后对他里面的两个属性name和weapon访问取值的又是两次调用getter，这样就恰好三次。但是当我再增加几个属性的时候结果还是三次。然后就在get中每次输出property，可以看到下面的几个输出： 123Symbol(util.inspect.custom)inspectSymbol(Symbol.iterator) 原因解释 ​ 因为我是在node里面运行这个代码的，所以console.log出来的实际上是将这个对象进行了处理输出了对象中的属性。实际上在chrome浏览器的控制台中输入的话运行出来的结果应该是一个代理的对象。然后由于在node中对对象进行了一些处理，所以难免会对get进行调用从而将对象转化成可视的字符串类型。以上这些代码实际上都是对这个对象进行的一系列的操作。是node中util自带的一些模块，就是为了弥补JavaScript中原始方法的不足。 3.使用代理实现自动的填充属性 当我们拥有一个对象具有很长一串属性的时候，通常我们可以通过代理来生成它没有的属性，避免带妈妈的重复和繁重。 12345678910111213141516function Folder()&#123; return new Proxy(&#123;&#125;,&#123; get:(target,property)=&gt;&#123; if(!(property in target))&#123; target[property] = new Folder(); &#125; return target[property]; &#125; &#125;)&#125;const myFile = new Folder();try&#123; myFile.root.first.second.next = "aa.txt";&#125;catch(e)&#123; console.log('error')&#125; 在try中虽然myFile并没有后面的一系列属性，但当我们读取的时候会调用代理中的get方法帮我们创建，这样的话即使这个属性不存在也不会出现undefined的问题。 4.使用代理实现数组的负索引 ​ 在python等语言中，是允许使用负索引来查找对象的，但是JavaScript不允许这样做，但是通过代理的方法我们可以来模拟这个过程。 123456789101112131415161718192021function createArray(array)&#123; return new Proxy(array,&#123; get:(target,index) =&gt;&#123; index = +index return array[index &lt; 0 ? target.length + index : index]; &#125;, set:(target,index,value) =&gt; &#123; index = +index return array[index &lt; 0 ? target.length + index : index] = value &#125;&#125;)&#125;const test = ['hh','sss','llll','iii']const test2 = createArray(test)console.log(test2[-1]);console.log(test2[-3]);console.log(test[-1])//执行的结果是// iii// sss// undefined 这里通过一元运算符+将属性名变成了数值。然后在代理中对他们的负数情况进行了相应的处理。然后新建一个test的数组，并创建它的代理，通过代理可以用负索引来访问数组中的值。 5.代理的性能消耗 相比较正常访问对象而言，使用代理去访问性能会慢很多，比如上个例子中，使用代理访问数组相互比较正常访问数组而言。在Chrome上时间为正常的50倍，所以使用代理的时候还是需要谨慎。如果是在多性能不敏感的情况下使用。]]></content>
      <categories>
        <category>javascript高级特性</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[apply和call的用法]]></title>
    <url>%2F2018%2F11%2F03%2Fcall%E5%92%8Capply%2F</url>
    <content type="text"><![CDATA[###1.基本用法 call和apply这两个方法在利用的时候一般是用来修改函数调用时候的this指向的。比如我们看下面的这个例子： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="test"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;//var getId = document.getElementById;var getId = function(id)&#123; return document.getElementById(id);&#125;getId('test');&lt;/script&gt;&lt;/html&gt; 这里是可以得到id为test的标签的，但是如果将getID换成注释中的那句话的时候，这时候在大多数浏览器中就会报错。这是因为如果在很多浏览器里面，getElementById这个方法内部实现需要this，这个this应该是指向document。当getElementById作为document的属性被调用的时候，方法内部的this确实是指向document的。但如果getId引用了document.getElementById之后，再去调用函数的话，就成了普通的函数调用，函数里面的this就指向了windows而不是document。 我们可以利用apply来实现这个调用的过程： 1234567document.getElementById = (function(func)&#123; return function()&#123; return func.apply(document,arguments) &#125;&#125;)(document.getElementById)var getId = document.getElementById;getId('test'); 这时候利用apply这个函数，将this所指向的对象指向了document，就能够实现原来的功能了。 利用apply和call可以修正我们函数的this，比如下面这个例子： 1234567document.getElementById('test').onclick = function(func)&#123; console.log(this.id); var func = function()&#123; console.log(this) &#125; func()&#125; 在这个例子中，外层的console.log能够正常输出test，但是内部函数输出的却是undefined，这时候如果还想让内部的函数像外部的函数一样正常输出的话，就需要利用apply来调用函数。 1234567document.getElementById('test').onclick = function(func)&#123; console.log(this.id); var func = function()&#123; console.log(this) &#125; func.call(this)&#125; ###2.利用Function.prototype.bind来指定函数内部的this 大部分的浏览器都实现了Function.prototype.bind这个函数用来指定Function的this指向。下面的这个例子用来模拟这个过程。 123456789101112131415Function.prototype.bind = function(context)&#123; var self = this; return function()&#123; return self.apply(context,arguments); &#125;&#125;var obj = &#123; name:"Jone"&#125;var func = function()&#123; console.log(this.name)&#125;.bind(obj);func(obj) 在定义Function.prototype.bind的时候，context就是我们想要修正的this对象。在函数体内，首先我们先用一个self对象将函数的引用保存起来，之后返回一个函数，这个函数就是在我们调用func()的时候被执行的。在函数的内部，self.apply才是执行原来的func函数，并且指定了context是这个函数的this。 3.借用其他对象的方法]]></content>
      <categories>
        <category>javascript设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js——Vuex相关用法]]></title>
    <url>%2F2018%2F11%2F03%2Fjs%E2%80%94%E2%80%94Vuex%E7%9B%B8%E5%85%B3%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[js——Vuex相关用法 平时在一个vue组件中，里面的数据和方法只有在但当前的.vue组件中可以访问和使用，其他的组件是无法访问的。但是在实际的业务逻辑中，经常有跨组件数据的需求，因此，Vuex的设计就是为了用来统一管理组件状态的。它定义了一系列的规范来使用和操作数据，使组件应用更加高效。 ###Vuex的基本用法： 首先通过NPM安装Vuex： npm install –save vuex 在main.js中通过Vue.use()使用Vuex： store包含了应用的数据（状态）和操作过程。任何组件使用同一store的操作的数据时，只要store的数据发生变化，对应的组件也会立刻更新。 在任何组件内，可以直接通过$store.state.count 读取这个数据： 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div class="hello"&gt; &lt;p&gt;&#123;&#123;$store.state.count&#125;&#125;&lt;/p&gt; &lt;button @click="handleIncrement"&gt;+1&lt;/button&gt; &lt;button @click="handleDecrease"&gt;-1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'HelloWorld', data () &#123; return &#123; msg: 'Welcome to Your Vue.js App' &#125; &#125;, methods:&#123; handleIncrement () &#123; this.$store.commit('increment'); &#125;, handleDecrease () &#123; this.$store.commit('decrease'); &#125; &#125;&#125;&lt;/script&gt; 当然，以上$store.state.count亦可以换成count，然后后面加上： 12345computed:&#123; count()&#123; return this.$store.state.count; &#125; &#125; 在组件内，来自store的数据只能读取，不能手动改变，改变store数据的唯一途径就是显式的提交mutatations。他是Vuex的第二个选项，用来直接修改state里的数据。 ###相关选项 Vuex还有其他的三个选项可以使用：getters、actions、modules。 123456789101112131415161718getters:&#123; getNum:state =&gt; &#123; return state.list.filter(item =&gt; item &lt; 10); &#125;, listCount:(state,getters) =&gt; &#123; return getters.getNum.length; &#125; &#125;//.vue文件中computed:&#123; count()&#123; return this.$store.state.count; &#125;, listCount () &#123; return this.$store.getters.listCount; &#125; &#125; 这里，getter也可以依赖于其他的getter，把getter作为第二个参数。如上例中的listCount。 注意的是，mutation里面不应该出现异步操作的数据，因此有了actions，他和mutation很像，但是提交的是mutation，并且可以异步操作业务逻辑。 action在组件中通过$store.dispatch触发，例如使用action加一： 123456789101112131415//main.jsactions:&#123; increment (context) &#123; context.commit('increment') &#125; &#125; //.vue methods:&#123; handleIncrement () &#123; this.$store.dispatch('increment'); &#125;, handleDecrease () &#123; this.$store.commit('decrease'); &#125; &#125;, 下面是处理异步操作的代码： 12345678910111213141516171819202122//main.jsactions:&#123; increment (context) &#123; return new Promise(resolve =&gt;&#123; setTimeout(()=&gt;&#123; context.commit('increment'); resolve(); &#125;,1000) &#125;) &#125; &#125; //.vue methods:&#123; handleIncrement () &#123; this.$store.dispatch('increment').then(()=&gt;&#123; console.log(this.$store.state.count) &#125;); &#125;, handleDecrease () &#123; this.$store.commit('decrease'); &#125; &#125;, mutation和actions看起来很相似，但一般涉及改变数据的时候用Vue，存在业务逻辑的时候用actions。 ###module的用法 最后一个是module，主要是用来将store分割到不同的模块，微地就是让main.js中的store看起来更友好。 12345678910111213141516171819202122232425262728var moduleA = &#123; state:&#123; count:0 &#125;, mutations:&#123; hello()&#123; console.log('hello') &#125; &#125;&#125;var moduleB = &#123; state:&#123; count:1 &#125;, mutations:&#123; get(state)&#123; console.log('state=' + state.count) &#125; &#125;&#125;const store = new Vuex.Store(&#123; modules:&#123; a:moduleA, b:moduleB &#125;&#125;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[组件的继承]]></title>
    <url>%2F2018%2F11%2F03%2Ftitle%20computed%E5%92%8Cwatch%2F</url>
    <content type="text"><![CDATA[1、组件的继承 通过组件的继承我们可以利用已定义的组件的一些特性。首先先看第一种定义的方式： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import Vue from 'vue'const component = &#123; // props:['active','propOne','onChange'], props:&#123; active:Boolean, propOne:&#123; require:true &#125; &#125;, template:` &lt;div&gt; &lt;input type="text" v-model="text"&gt; &lt;span @click="handleChange"&gt;&#123;&#123;propOne&#125;&#125;&lt;/span&gt; &lt;span v-show="active"&gt;show&lt;/span&gt; &lt;/div&gt; `, data()&#123; return &#123; text:0 &#125; &#125;, mounted()&#123; console.log('comp instance'); &#125;, methods:&#123; handleChange()&#123; //this.onChange() this.$emit('change') &#125; &#125;&#125;const CompVue = Vue.extend(component)new CompVue(&#123; el:'#root', propsData:&#123; propOne:123, active:true &#125;, data()&#123; return &#123; text:123 &#125; &#125;, mounted()&#123; console.log('this instance'); &#125;&#125;) ​ 在这个里面，CompVue继承了名为component这样的一个组件，并且在里面实现了自己的一些方法。首先，如果这个时候需要和被继承组件中的子组件通信的时候，需要利用propsData进行传递，利用原来的props是没有效果的。然后就是在继承的组件当中，data会自动覆盖掉原先的data。但是对于mounted而言是不会被覆盖的，而是先执行被继承对象中的mounted方法，再调用自己的mounted方法。 当然，还有一种定义继承的方式： 12345678910111213141516const comp2 = &#123; extends:component, data()&#123; return&#123; text:555 &#125; &#125;&#125;new Vue(&#123; el:'#root', components:&#123; comp:comp2 &#125;, template:`&lt;comp&gt;&lt;/comp&gt;`&#125;) 二、组件的parent利用$parent这个变量可以找到一个组件的父组件，并且通过this. $parent.$options.name可以查到他父组件的名字。 1234567891011121314151617181920212223242526272829const comp2 = &#123; extends:component, data()&#123; return&#123; text:555 &#125; &#125;, mounted()&#123; console.log(this.$parent.$options.name) &#125;&#125;new Vue(&#123; name:&apos;myTest&apos;, el:&apos;#root&apos;, components:&#123; comp:comp2 &#125;, data()&#123; return &#123; text:2333 &#125; &#125;, template:` &lt;div&gt; &lt;span&gt;&#123;&#123;text&#125;&#125;&lt;/span&gt; &lt;comp&gt;&lt;/comp&gt; &lt;/div&gt;`&#125;) 当然，也可以通过$parent来改变响应的值。但是尽量不要去这样做。父组件也是可以进行设置的： 12345678910111213141516const parent = new Vue(&#123; name:'parent'&#125;)const comp2 = &#123; parent:parent, extends:component, data()&#123; return&#123; text:555 &#125; &#125;, mounted()&#123; console.log(this.$parent.$options.name) &#125;&#125; 这样声明是没有用的，结果还将是parent为调用该组件的名称，这时候想要定义父组件必须在new一个Vue的时候声明才有效果。 接下来看一个多层调用的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import Vue from 'vue'const childComponents = &#123; template:` &lt;div&gt;child child &#123;&#123;value&#125;&#125;&lt;/div&gt; `, inject:['yeye','value'], mounted()&#123; console.log(this.yeye) &#125;&#125;const component = &#123; props:&#123; active:Boolean, propOne:&#123; require:true &#125; &#125;, data()&#123; return &#123; text:0, style:&#123; width:'200px', height:'200px', border:'1px black solid' &#125; &#125; &#125;, mounted()&#123; console.log('comp instance'); &#125;, components:&#123; childComponents &#125;, template:` &lt;div :style="style"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;child-components&gt;&lt;/child-components&gt; &lt;/div&gt; `&#125;new Vue(&#123; name:'myTest', el:'#root', components:&#123; comp:component &#125;, provide()&#123; return&#123; yeye:this, value:this.value &#125; &#125;, data()&#123; return &#123; text:2333, value:222222 &#125; &#125;, mounted()&#123; // console.log(this.$parent.$options.name) &#125;, template:` &lt;div&gt; &lt;comp&gt; &lt;span&gt;&#123;&#123;text&#125;&#125;&lt;/span&gt; &lt;/comp&gt; &lt;input type="text" v-model="value"/&gt; &lt;/div&gt;`&#125;) 但是是没有办法访问越级的组件的，这个时候就需要去做一些处理。 首先在”爷爷辈“的组件中，声明一个provide方法，这样才会在Vue对象初始化的过程中得到里面的值。 123456provide()&#123; return&#123; yeye:this, value:this.value &#125; &#125;, 然后在”孙子辈“里面再去利用inject调用： 123456789const childComponents = &#123; template:` &lt;div&gt;child child &#123;&#123;value&#125;&#125;&lt;/div&gt; `, inject:['yeye','value'], mounted()&#123; console.log(this.yeye) &#125;&#125; 但是这时候，如果在input中输入一个数的话，孙子中绑定的值是不会变化的，这是因为默认情况下provide是不提供Vue的react属性的，可以做下面的处理： 1234567891011provide()&#123; const data = &#123;&#125; Object.defineProperty(data,'value',&#123; get: ()=&gt; this.value, enumerable:true &#125;) return&#123; yeye:this, data &#125; &#125;, 也就是子组件在每次访问value这个属性的时候，实际上是在访问get方法，然后访问到value值的变化，这也就是Vue实现的一个原理，但是Vue官方文档中可能之后会被移除。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js异步编程——async的用法]]></title>
    <url>%2F2018%2F11%2F03%2Fjs%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94async%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[生成器的简单回顾出现的问题​ 在生成器的时候，我们说可以利用生成器的方式去完成一段异步回调。这样的话可以避免多个promise对象的级联造成代码的冗杂和难以维护。但是在运用生成器的时候，下面的这段代码会出现问题： 123456789101112131415161718192021222324const readFile = function () &#123; return new Promise(function (resolve, reject) &#123; setTimeout(()=&gt;&#123; console.log('aaaa') resolve('hhh') &#125;,1000) &#125;);&#125;;const gen = function* () &#123; const f1 = yield readFile(); const f2 = yield readFile(); console.log(f1); console.log(f2);&#125;;var test = gen()test.next();test.next();test.next();//运行的结果是：// undefined// undefined// aaaa// aaaa 解决的方案​ 可以看到，上面的这段代码本来我们预期的结果应该是等到前面的异步代码执行命完毕之后再执行同步代码。但是这个时候由于我们连续调用了三次next方法，这时候同步的操作被先执行了。这是有问题的，我们需要在异步操作之后再进行后面的操作，如果非要用生成器来实现的话，可以用下面的方式来解决： 123456789101112131415161718192021222324252627282930313233343536const readFile = function () &#123; return new Promise(function (resolve, reject) &#123; setTimeout(()=&gt;&#123; console.log('aaaa') resolve('hhh') &#125;,2000) &#125;);&#125;;const gen = function* () &#123; const f1 = yield readFile(); const f2 = yield readFile(); console.log(f1); console.log(f2);&#125;;var test = gen()test.next = (function(func)&#123; return function()&#123; var obj = func.apply(test,arguments); var aa = obj.value; if(obj.done) return; if(aa instanceof Promise)&#123; // console.log('这是一个异步操作') aa.then((args)=&gt;&#123; console.log(args) test.next() return args; &#125;) &#125;else&#123; // console.log('这是一个同步操作') test.next() &#125; &#125;&#125;)(test.next)test.next(); ​ 这样的话发现代码是按照正常的顺序执行了，但是还是有个问题，我们的f1和f2的返回值还是一个undefined，这是因为上面的函数很难返回一个值，如果非要这样的话目前我想到的办法是在生成器中声明一个对象，在每次执行异步操作的时候都传入这个参数，并且每次都会去改变对应的值，这样的话就能够实现上述功能： 1234567891011121314151617181920212223242526272829303132333435363738394041const readFile = function (args) &#123; return new Promise(function (resolve, reject) &#123; setTimeout(()=&gt;&#123; console.log('aaaa') args.f1 = 2 args.f2 = 32 resolve('hhh') &#125;,1000) &#125;);&#125;;const gen = function* () &#123; var canshu = &#123; f1:undefined, f2:undefined &#125; yield readFile(canshu); yield readFile(canshu); console.log(canshu.f1); console.log(canshu.f2);&#125;;var test = gen()test.next = (function(func)&#123; return function()&#123; var obj = func.apply(test,arguments); var aa = obj.value; if(obj.done) return; if(aa instanceof Promise)&#123; // console.log('这是一个异步操作') aa.then((args)=&gt;&#123; test.next() return args; &#125;) &#125;else&#123; // console.log('这是一个同步操作') test.next() &#125; &#125;&#125;)(test.next)test.next(); ​ 上述代码是我们运用生成器来写的一个按正常代码顺序执行混合异步和同步操作的一个例子。实质是如果当前的操作是一个异步操作，那么他的下一个操作是放在他的Promise对象中的then方法里的，只有在当前的异步操作执行完毕的时候才会进行后续的操作。但是如果当前的操作是个同步的操作。那么就直接执行后续的操作，这样就实现了我们正常的代码顺序。 通过async实现的方法一个实例​ 但是可以看得出，由生成器来解决异步问题，需要我们自己去改写Next方法，代码比较复杂，并且返回参数的时候是不容易的。为了更简单的操作异步程序，ES7语法为我们提供了一个更简单的操作方式——使用async来处理。实际上async就是Generator的语法糖。现在我们用async来写刚刚我们的异步操作的例子，可以得到： 123456789101112131415const setFunc = function asyncFunction(args1)&#123; return new Promise((resolve) =&gt; &#123; setTimeout(()=&gt;&#123; console.log('nihao') resolve(args1) &#125;,1000) &#125;)&#125;const gen =async function() &#123; const f1 = await setFunc('this is f1'); console.log(f1); const f2 = await setFunc('this is f2'); console.log(f2);&#125;;var test = gen() ​ 首先这里定义了一个异步的函数setFunc()，之后对这个setFunc进行一些操作，这个函数返回了一个Promise对象，其中进行了一些异步的操作。之后用await执行这个异步的操作，之后在异步操作之后进行了一些同步的操作最后的输出结果表明，在async函数里，通过await声明的函数可以进行相关的异步操作，并且后面的操作会等到这个异步操作结束之后进行，实质是根据生成器的原理进行的相关操作。 async函数返回值​ async函数返回的是一个Promise对象，其内部的return语句会被认为是调用了resolve函数，返回值即是这个函数的参数。同样，在async函数里面也可以抛出一个异常，会使得Promise调用reject函数并catch住这个异常。 1234567891011121314async function f1()&#123; return 'func1'&#125;async function f2()&#123; throw new Error('Something error')&#125;f1().then((args)=&gt;&#123; console.log('this is ' + args)&#125;)f2().then((args)=&gt;&#123; console.log('this is ' + args)&#125;,(args)=&gt;&#123; console.log('this is an error\n' + args)&#125;) await命令​ await一般后面跟的是一个Promise对象，如果不是的话就会返回对应的值。 ​ 尤其需要注意的是，如果await后面的Promise对象是reject，那么就会给回调函数中的catch接收，但是这里的问题就是，如果前面出现了reject，对应后面的内容就不能执行了。这时候就需要在await的异步操作后面加上catch操作，从而进行异常的处理。 12345678910const gen =async function() &#123; const f1 = await setFunc('this is f1').catch(()=&gt;&#123; console.log('test1') &#125;); console.log(f1); const f2 = await setFunc('this is f2').catch(()=&gt;&#123; console.log('test2') &#125;); console.log(f2);&#125;; 使用的注意点####同时进行异步操作 ​ 由于await实际上是将异步转化成同步的一种方式，对于几个相互独立的异步操作，应该让其同时进行异步操作，而不应该用await让被一个进程阻塞其他进程的进行，这样会十分耗时。应该用下面的两种写法让他们同时执行： 123456789101112131415161718192021const setFunc1 = function asyncFunction(args1)&#123; return new Promise((resolve,reject) =&gt; &#123; setTimeout(()=&gt;&#123; console.log('nihao') resolve(args1) &#125;,1000) &#125;)&#125;const setFunc2 = function asyncFunction(args1)&#123; return new Promise((resolve,reject) =&gt; &#123; setTimeout(()=&gt;&#123; console.log('nihao') resolve(args1) &#125;,1000) &#125;)&#125;const gen2 = async function()&#123; const [f1,f2] = await Promise.all([setFunc1(),setFunc2()]) console.log('this is the end')&#125;gen2() 当然，如果非要用await，上面的代码也可以转化成一下的代码： 1234let fooPromise = getFoo();let barPromise = getBar();let foo = await fooPromise;let bar = await barPromise; 两者都是等效的，都可以让多个独立的异步操作在同一时间进行。 在普通函数中首先await必须要在async声明的函数里面，否则会报错。首先看下面的这个例子： 123456789101112131415161718function myPost(data)&#123; return new Promise((resolve)=&gt;&#123; setTimeout(()=&gt;&#123; console.log('This is ' + data) &#125;,1000) &#125;)&#125;function myTest()&#123; const docs = [ &#123;aa:'ss'&#125;, &#123;bb:'uu'&#125;, &#123;cc:'oo'&#125; ] docs.forEach(async function(doc)&#123; await myPost(JSON.stringify(doc)) &#125;)&#125;myTest() 这样写的await运行出来的结果一般都不是我们期望的，一个结束之后在运行另外一个，而是三个同时在运行，是并发执行。正确的方式应该是： 12345678910111213141516171819function myPost(data)&#123; return new Promise((resolve)=&gt;&#123; setTimeout(()=&gt;&#123; console.log('This is ' + data) resolve() &#125;,1000) &#125;)&#125;async function myTest()&#123; const docs = [ &#123;aa:'ss'&#125;, &#123;bb:'uu'&#125;, &#123;cc:'oo'&#125; ] for(let doc of docs)&#123; await myPost(JSON.stringify(doc)) &#125;&#125;myTest() ​ 注意在每个异步操作里面都应该加上resolve()，不然程序只会输出JSON数据的第一项之后就不再输出。如果这时候确实有一个需求是前面需要并发地执行几个操作，后面再对他们的结果进行一些处理的话，这时候就需要用下面的两种写法来实现： 123456789101112131415161718192021async function test()&#123; let obj = [ &#123;name:'liming'&#125;, &#123;age:18&#125;, &#123;sex:'man'&#125; ] let promises = obj.map((bd) =&gt; myPost(JSON.stringify(bd))); await Promise.all(promises); console.log('This is the end')&#125;//第二种写法async function test()&#123; let obj = [ &#123;name:'liming'&#125;, &#123;age:18&#125;, &#123;sex:'man'&#125; ] let promises = obj.map((bd) =&gt; myPost(JSON.stringify(bd))); await Promise.all(promises); console.log('This is the end')&#125; 顶层await​ 目前，esm模块加载器支持顶层await，即这时候await命令可以不放在async函数内，直接使用即可。但是这种写法的脚本必须使用esm加载器，否则不能执行。]]></content>
      <categories>
        <category>web基础知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[computed和watch]]></title>
    <url>%2F2018%2F11%2F03%2F%E4%B8%80%E3%80%81computed%E7%9B%B8%E5%85%B3%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[一、computed相关的用法说明先看下面这行代码的效果： 123456789101112131415161718192021222324252627282930import Vue from 'vue'new Vue(&#123; el:'#root', template:` &lt;div&gt; &lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;getname()&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;number&#125;&#125;&lt;/div&gt; &lt;input type="text" v-model="number"/&gt; &lt;/div&gt; `, data:&#123; firstname:'Jone', lastname:'Lou', number:0 &#125;, computed:&#123; name()&#123; console.log('new name') return `$&#123;this.firstname&#125; $&#123;this.lastname&#125;` &#125; &#125;, methods:&#123; getname()&#123; console.log('new name invoke') return `$&#123;this.firstname&#125; $&#123;this.lastname&#125;` &#125; &#125;&#125;) ​ 这里在computed中声明了一个name()方法和getname()方法，在改变输入框的值时候，整个应用的值是会被重新渲染的，可以发现computed中的方法并没有被触发，但是getname()中的方法被触发了。这对性能的优化是很有效的。但是并不是改变的时候都不会触发。如果这个时候在template中加上： 12&lt;input type="text" v-model="firstname"/&gt; &lt;input type="text" v-model="lastname"/&gt; 并且在输入框中改变输入的值的时候，就会看见input中的值改变了computed中的方法被触发了。这是当它依赖的值被改变的时候它的计算属性会被调用。 当然，computed还可以做一些属性的设置： 1234567891011121314computed:&#123; name:&#123; get()&#123; console.log('new name'); return `$&#123;this.firstname&#125; $&#123;this.lastname&#125;` &#125;, set(name)&#123; const names = name.split(' ') this.firstname = names[0] this.lastname = names[1] console.log('hhh') &#125; &#125; &#125;, 这里可以对name设置get和set方法从而实现读取的相关操作。 二、watchwatch可以对一个变量的值的变化进行监听，并做一些响应的操作。这里我们对firstname及逆行一次监听： 12345watch:&#123; firstname(newname,oldname)&#123; this.fullname = newname+" "+this.lastname &#125;&#125;, 这里引入了一个新的变量叫fullname，并且在上面的div中对其进行渲染，可以看见，刚开始打开的时候并不能看见fullname的值，这是因为watch方法最初绑定的时候是不会被渲染的，只有被监听的值发生变化的时候才会被执行。当然我们也可以对其进行一些处理： 12345678watch:&#123; firstname:&#123; handler(newname,oldname)&#123; this.fullname = newname+" "+this.lastname &#125;, immediate:true &#125;&#125; 这样在初始化的时候就可以将数据渲染到页面上了。watch不适合用来做数据的显示，但适合见町名数据的变化并在后台做一些相关的处理。 当然，watch还有一个属性叫做deep这里做一个例子： 123456789101112//data obj:&#123; a:'123' &#125; //watchobj:&#123; handler(newname,oldname)&#123; console.log('obj.a changed') &#125;, immediate:true, //deep:true &#125; ​ 这里，如果在输入框中仅仅改变obj.a的值的时候，watch里面的方法并不会被触发，这是因为对象中的watch只会监听对象的变化，但是改变内部的属性是不起作用的。常用的办法就是加上deep:true。但这里也会有一个问题，每当对象中的属性发生变化的时候，不管和a这个属性有关还是无关，都会触发这个方法，这对性能是有影响的。一个好的处理办法就是将监听的obj换成字符串的’obj.a’。这时候就会只监听a属性。同时注意，在computed中不要对监听值进行修改，不然可能会导致无限次触发。]]></content>
  </entry>
  <entry>
    <title><![CDATA[webpack]]></title>
    <url>%2F2017%2F02%2F22%2F%E5%89%8D%E7%AB%AF11_2%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94webpack%2F</url>
    <content type="text"><![CDATA[前端11_2笔记——webpack 安装webpack配置 首先在新建的项目中npm init新建一个npm项目，然后安装webpack相关的组件 1npm i webpack vue vue-loader 同时还需要安装： 1npm i css-loader vue-template-compiler 新建一个app.vue并写入一些组件，新建一个webpack.config.js进行一些设置。 新建一个index.js进行入口文件的设置 1234567891011import Vue from 'vue'import App from './app.vue'import './styles/test.css'import './styles/test-stylus.styl'const root = document.createElement('div');document.body.appendChild(root);new Vue(&#123; render:(h) =&gt; h(App)&#125;).$mount(root) webpack只支持js文件并且只支持ES5的语法，所以需要进行一些处理： 12345678module:&#123; rules:[ &#123; test:/\.vue$/, loader:'vue-loader' &#125; ] &#125;, 并且vue-loader在15.*之后的版本都是 vue-loader的使用都是需要伴生 VueLoaderPlugin的，具体内容可详见https://vue-loader.vuejs.org/guide/#vue-cli 所以进行以以下处理： 123456789101112131415161718// webpack.config.jsconst VueLoaderPlugin = require('vue-loader/lib/plugin')module.exports = &#123; module: &#123; rules: [ // ... other rules &#123; test: /\.vue$/, loader: 'vue-loader' &#125; ] &#125;, plugins: [ // make sure to include the plugin! new VueLoaderPlugin() ]&#125; 之后运行npm run dev就能够看见新建了一个dist的文件，并且底下有一个bundle.js文件，webpack所作的工作就是把不同的的静态资源文件打包成一个.js文件，然后在html中去引入这个文件实现。因为在http中将零散的文件打包成一个减少http请求的次数。 1.处理.vue文件 在webpack.config.js文件中，利用module来设置rules： 1234&#123; test:/\.vue$/, loader:'vue-loader'&#125; 2.处理CSS文件 利用css-loader来处理CSS文件，但是在实际运用的过程当中会有不同的处理方式，所以这时候需要换一种写法： 12 最终，CSS代码会写入到js文件中去，并且最终会引入到html当中去。 3.图片的处理方式 这里loader使用一个对象去写，因为实际上一个对象是可以进行配置的，利用options可以对其进行配置： 这里，url-loader可以将图片转换为Base-64代码直接插入到js中去，不用生成新的图片，这对于我们几KB的文件是很有用的，就不用生成http请求。url-loader实际上封装了file-loader，其就是将图片进行读取并进行一些简单的操作之后重新存储。limit设置了转换图片的大小。 12345loader:'url-loader',options:&#123; limit:1024, name:'[name]-aaa.[ext]'&#125; 配置之后需要安装相应的模块： 1npm i style-loader url-loader file-loader 4.CSS CSS预处理器就是用模块化的思想去写CSS代码。比如利用.styl 12345678&#123; test:/\.styl/, use:[ 'style-loader', 'css-loader', 'stylus-loader' ]&#125; 并安装stylus和stylus-loader 配置webpack-dev-server首先安装这个包 1npm i webpack-dev-server 在package.json中的scripts加入”dev”:”webpack-dev-server –config webpack.config.js” 然后在webpack.config.js中全局加入target:’web’，同时需要判断正式环境和开发环境： 安装cross-env可以保证我们在不同的平台执行同一个脚本,在package.json中的build下加入 12"build": "cross-env NODE_ENV=production webpack --config webpack.config.js","dev": "cross-env NODE_ENV=development webpack-dev-server --config webpack.config.js" 当启动脚本的时候设置的环境变量全部都是设置在process.env里面的，可以在process.env中设置多个变量名并读取到这些变量。 然后设置当环境为production的时候，进行对server的配置： 1234567891011if(isDev)&#123; config.devServer = &#123; port:'8000', //设置成0.0.0.0好处是可以通过内网的IP进行访问，而localhost就不行 host:'0.0.0.0', //当编译有错误的时候，可以将我们的错误显示到我们的网页上 overlay:&#123; errors:true &#125; &#125;&#125; 现在需要一个html页面来显示我们的内容： 首先安装一个插件： 1npm i html-webpack-plugin 之后在最前面引入这个插件： 1const HTMLPlugin = require('html-webpack-plugin') 并进行调用： 123456789101112plugins: [ // make sure to include the plugin! new VueLoaderPlugin(), new HTMLPlugin(), //这个是用来给wewbpack在编译的时候和js代码运行时判断环境 //提供相关的框架去区分打包 new webpack.DefinePlugin(&#123; 'process.env':&#123; NODE_ENV:isDev ? '"development"' : '"production"' &#125; &#125;) ] 热加载在config.devServer中设置 1hot:true, 然后设置下面的两个选项： 1234config.plugins.push( new webpack.HotModuleReplacementPlugin(), new webpack.NoEmitOnErrorsPlugin() ) 并在前面引入webpack： 1const webpack = require('webpack') 并且设置devtool 1234//这是帮助我们调试代码 //利用sourcemap进行代码的映射，在浏览器中打开的还是我们正常写的代码。 //提高效率和准确性 config.devtool = '#cheap-module-eval-source-map' 最终，在webpack.config.js中的代码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384‘const path = require('path')const VueLoaderPlugin = require('vue-loader/lib/plugin')const HTMLPlugin = require('html-webpack-plugin')const webpack = require('webpack')const isDev = process.env.NODE_ENV === 'development'const config = &#123; target:'web', entry:path.join(__dirname,'src/index.js'), output:&#123; filename:'bundle.js', path:path.join(__dirname,'dist') &#125;, module:&#123; rules:[ &#123; test:/\.vue$/, loader:'vue-loader' &#125;,&#123; test:/\.css$/, use:[ 'style-loader', 'css-loader' ] &#125;,&#123; test:/\.(gif|jpg|jpeg|png|svg)$/, use:[ &#123; loader:'url-loader', options:&#123; limit:1024, name:'[name]-aaa.[ext]' &#125; &#125; ] &#125;,&#123; test:/\.styl/, use:[ 'style-loader', 'css-loader', 'stylus-loader' ] &#125; ] &#125;, plugins: [ // make sure to include the plugin! new VueLoaderPlugin(), new HTMLPlugin(), //这个是用来给wewbpack在编译的时候和js代码运行时判断环境 //提供相关的框架去区分打包 new webpack.DefinePlugin(&#123; 'process.env':&#123; NODE_ENV:isDev ? '"development"' : '"production"' &#125; &#125;) ]&#125;if(isDev)&#123; //这是帮助我们调试代码 //利用sourcemap进行代码的映射，在浏览器中打开的还是我们正常写的代码。 //提高效率和准确性 config.devtool = '#cheap-module-eval-source-map' config.devServer = &#123; port:'8000', //设置成0.0.0.0好处是可以通过内网的IP进行访问，而localhost就不行 host:'0.0.0.0', //当编译有错误的时候，可以将我们的错误显示到我们的网页上 overlay:&#123; errors:true &#125;, //每次编译完成后都会打开浏览器 //open:true //hot不会重新加载页面而是直接渲染组件。 hot:true, &#125; config.plugins.push( new webpack.HotModuleReplacementPlugin(), new webpack.NoEmitOnErrorsPlugin() )&#125;module.exports = config; CSS分离： 之前的CSS代码在打包之后都是在同一个.js文件中，并且里面内容很多不容易找到，这时候需要利用相关的插件对CSS进行分离。 首先先npm i extract-text-webpack-plugin 然后在webpack.config.js文件中添加const ExtractPlugin = require(‘extract-text-webpack-plugin’)，这个就是将我们的非js代码单独打包成一个文件，因为这个文件有可能会作为缓存和利用js将一些样式写入页面中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130const path = require('path')const VueLoaderPlugin = require('vue-loader/lib/plugin')const HTMLPlugin = require('html-webpack-plugin')const webpack = require('webpack')const ExtractPlugin = require('extract-text-webpack-plugin')const isDev = process.env.NODE_ENV === 'development'const config = &#123; target:'web', entry:path.join(__dirname,'src/index.js'), output:&#123; filename:'bundle.js', path:path.join(__dirname,'dist') &#125;, module:&#123; rules:[ &#123; test:/\.vue$/, loader:'vue-loader' &#125;, &#123; test:/\.jsx$/, loader:'babel-loader' &#125;, &#123; test:/\.(gif|jpg|jpeg|png|svg)$/, use:[ &#123; loader:'url-loader', options:&#123; limit:1024, name:'[name]-aaa.[ext]' &#125; &#125; ] &#125; ] &#125;, plugins: [ // make sure to include the plugin! new VueLoaderPlugin(), new HTMLPlugin(), //这个是用来给wewbpack在编译的时候和js代码运行时判断环境 //提供相关的框架去区分打包 new webpack.DefinePlugin(&#123; 'process.env':&#123; NODE_ENV:isDev ? '"development"' : '"production"' &#125; &#125;) ]&#125;if(isDev)&#123; config.module.rules.push(&#123; test:/\.css$/, use:[ 'style-loader', 'css-loader' ] &#125;,&#123; test:/\.styl/, use:[ 'style-loader', 'css-loader', &#123; loader:'postcss-loader', options:&#123; sourceMap:true, &#125; &#125;, 'stylus-loader' ] &#125;) //这是帮助我们调试代码 //利用sourcemap进行代码的映射，在浏览器中打开的还是我们正常写的代码。 //提高效率和准确性 config.devtool = '#cheap-module-eval-source-map' config.devServer = &#123; port:'8000', //设置成0.0.0.0好处是可以通过内网的IP进行访问，而localhost就不行 host:'0.0.0.0', //当编译有错误的时候，可以将我们的错误显示到我们的网页上 overlay:&#123; errors:true &#125;, //每次编译完成后都会打开浏览器 //open:true //hot不会重新加载页面而是直接渲染组件。 hot:true, &#125; config.plugins.push( new webpack.HotModuleReplacementPlugin(), new webpack.NoEmitOnErrorsPlugin() )&#125; else&#123; config.output.filename = '[name].[chunkhash:8].js' config.module.rules.push(&#123; test:/\.styl/, use:ExtractPlugin.extract(&#123; fallback:'style-loader', use:[ 'css-loader', &#123; loader:'postcss-loader', options:&#123; sourceMap:true, &#125; &#125;, 'stylus-loader' ] &#125;) &#125;,&#123; test:/\.css$/, use:ExtractPlugin.extract(&#123; fallback:'style-loader', use:[ &#123; use:[ 'css-loader' ] &#125; ] &#125;) &#125;) config.plugins.push( new ExtractPlugin('styles.[contentHash:8]') )&#125;module.exports = config;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
</search>
